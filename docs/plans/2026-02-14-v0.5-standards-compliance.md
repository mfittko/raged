# v0.5 Standards Compliance Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix all violations of raged's own coding standards (AGENTS.md) — refactor fat handlers, add JSON Schema validation, structured errors, comprehensive tests, and CI/CD.

**Architecture:** Extract business logic from route handlers into service modules, add Fastify JSON Schema validation, add Vitest unit + integration tests, add GitHub Actions CI.

**Tech Stack:** TypeScript, Fastify, Vitest, GitHub Actions

---

### Task 1: Add Vitest and test infrastructure

**Files:**
- Modify: `api/package.json`
- Create: `api/vitest.config.ts`

**Step 1: Install vitest as a dev dependency**

```bash
cd api && npm install --save-dev vitest
```

**Step 2: Create `api/vitest.config.ts`**

> Note: `vitest.config.ts` is a tool-specific config file where Vitest requires a default export. This is a scoped exception to the named-exports-only rule for application modules.

```typescript
import { defineConfig } from "vitest/config";

const vitestConfig = defineConfig({
  test: {
    globals: false,
    environment: "node",
    include: ["src/**/*.test.ts"],
    testTimeout: 10_000,
  },
});

export default vitestConfig;
```

**Step 3: Add the `test` script to `api/package.json`**

In the `"scripts"` section, add:

```json
"test": "vitest run",
"test:watch": "vitest"
```

The full scripts block becomes:

```json
"scripts": {
  "dev": "tsx watch src/server.ts",
  "build": "tsc -p tsconfig.json",
  "start": "node dist/server.js",
  "test": "vitest run",
  "test:watch": "vitest"
}
```

**Step 4: Verify vitest runs with zero tests**

```bash
cd api && npx vitest run
```

Expected output (approximate):

```
 RUN  v3.x.x /path/to/api

No test files found, exiting with code 1
```

This is expected — there are no test files yet. Vitest exits with code 1 when no tests are found. The important thing is that vitest itself loads without errors.

**Step 5: Update `api/tsconfig.json` to exclude test files from build output**

Add an `"exclude"` field so `.test.ts` files are not compiled to `dist/`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "strict": true,
    "types": ["node"],
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src"],
  "exclude": ["src/**/*.test.ts"]
}
```

**Step 6: Commit**

```bash
git add api/package.json api/package-lock.json api/vitest.config.ts api/tsconfig.json
git commit -m "chore: add vitest test infrastructure to api"
```

---

### Task 2: Unit tests for chunking.ts

**Files:**
- Create: `api/src/chunking.test.ts`

**Step 1: Write tests for `chunkText`**

```typescript
import { describe, it, expect } from "vitest";
import { chunkText } from "./chunking.js";

describe("chunkText", () => {
  it("returns an empty string in a single-element array for empty input", () => {
    // After trim(), empty string has length 0 which is <= maxChars, so returns [""]
    const result = chunkText("");
    expect(result).toEqual([""]);
  });

  it("returns a single chunk for short text", () => {
    const text = "Hello, world!";
    const result = chunkText(text);
    expect(result).toEqual(["Hello, world!"]);
  });

  it("returns a single chunk when text length equals maxChars", () => {
    const text = "a".repeat(1800);
    const result = chunkText(text);
    expect(result).toHaveLength(1);
    expect(result[0]).toBe(text);
  });

  it("splits long text into multiple chunks", () => {
    // Create text with lines that will exceed 1800 chars total
    const line = "x".repeat(100) + "\n";
    const text = line.repeat(30); // 30 * 101 = 3030 chars
    const result = chunkText(text);
    expect(result.length).toBeGreaterThan(1);
    // Each chunk should be at most maxChars
    for (const chunk of result) {
      expect(chunk.length).toBeLessThanOrEqual(1800);
    }
  });

  it("normalizes CRLF to LF", () => {
    const text = "line one\r\nline two\r\nline three";
    const result = chunkText(text);
    expect(result).toEqual(["line one\nline two\nline three"]);
  });

  it("trims leading and trailing whitespace", () => {
    const text = "  \n  hello  \n  ";
    const result = chunkText(text);
    expect(result).toEqual(["hello"]);
  });

  it("splits on line boundaries, not mid-line", () => {
    // Create lines where accumulating them crosses the boundary at a line break
    const lines: string[] = [];
    for (let i = 0; i < 40; i++) {
      lines.push(`Line ${i}: ${"y".repeat(80)}`);
    }
    const text = lines.join("\n"); // ~40 * ~88 = ~3520 chars
    const result = chunkText(text);
    expect(result.length).toBeGreaterThan(1);
    // Verify no chunk starts or ends mid-word within a known line
    for (const chunk of result) {
      // Each chunk should consist of complete lines (no partial lines)
      const chunkLines = chunk.split("\n");
      for (const cl of chunkLines) {
        expect(cl).toMatch(/^Line \d+: y+$/);
      }
    }
  });

  it("handles a single line longer than maxChars", () => {
    // A single line with no newlines that exceeds maxChars
    const longLine = "z".repeat(3600);
    const result = chunkText(longLine);
    // The algorithm splits on newlines; a single long line with no newlines
    // will be kept as one chunk since there are no line breaks to split on
    expect(result).toHaveLength(1);
    expect(result[0]).toBe(longLine);
  });

  it("respects custom maxChars parameter", () => {
    const text = "aaa\nbbb\nccc\nddd\neee\nfff";
    const result = chunkText(text, 10);
    expect(result.length).toBeGreaterThan(1);
    for (const chunk of result) {
      expect(chunk.length).toBeLessThanOrEqual(10);
    }
  });

  it("does not produce empty chunks", () => {
    const text = "hello\n\n\nworld\n\n\nfoo";
    const result = chunkText(text);
    for (const chunk of result) {
      expect(chunk.trim().length).toBeGreaterThan(0);
    }
  });
});
```

**Step 2: Run the tests and verify they pass**

```bash
cd api && npx vitest run src/chunking.test.ts
```

Expected output:

```
 ✓ src/chunking.test.ts (10 tests)

 Test Files  1 passed (1)
      Tests  10 passed (10)
```

**Step 3: Commit**

```bash
git add api/src/chunking.test.ts
git commit -m "test: add unit tests for chunkText"
```

---

### Task 3: Unit tests for auth.ts

**Files:**
- Modify: `api/src/auth.ts` (export `timingSafeEqual` for testing)
- Create: `api/src/auth.test.ts`

**Step 1: Export `timingSafeEqual` so it can be tested**

Change `api/src/auth.ts` from:

```typescript
function timingSafeEqual(a: string, b: string): boolean {
```

to:

```typescript
export function timingSafeEqual(a: string, b: string): boolean {
```

The full updated `api/src/auth.ts`:

```typescript
import type { FastifyInstance, FastifyRequest, FastifyReply } from "fastify";

export function timingSafeEqual(a: string, b: string): boolean {
  if (a.length !== b.length) return false;
  let out = 0;
  for (let i = 0; i < a.length; i++) out |= a.charCodeAt(i) ^ b.charCodeAt(i);
  return out === 0;
}

export function registerAuth(app: FastifyInstance) {
  const token = process.env.RAGED_API_TOKEN || "";
  if (!token) return;

  app.addHook("onRequest", async (req: FastifyRequest, reply: FastifyReply) => {
    if (req.method === "GET" && req.url.startsWith("/healthz")) return;

    const auth = (req.headers["authorization"] || "").toString();
    const prefix = "Bearer ";
    if (!auth.startsWith(prefix)) return reply.code(401).send({ error: "Unauthorized" });

    const provided = auth.slice(prefix.length);
    if (!timingSafeEqual(provided, token)) return reply.code(401).send({ error: "Unauthorized" });
  });
}
```

**Step 2: Write tests for auth**

Create `api/src/auth.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import Fastify from "fastify";
import { timingSafeEqual, registerAuth } from "./auth.js";

describe("timingSafeEqual", () => {
  it("returns true for identical strings", () => {
    expect(timingSafeEqual("abc", "abc")).toBe(true);
  });

  it("returns false for different strings of same length", () => {
    expect(timingSafeEqual("abc", "abd")).toBe(false);
  });

  it("returns false for different lengths", () => {
    expect(timingSafeEqual("abc", "abcd")).toBe(false);
  });

  it("returns true for empty strings", () => {
    expect(timingSafeEqual("", "")).toBe(true);
  });

  it("returns false when only one is empty", () => {
    expect(timingSafeEqual("", "a")).toBe(false);
  });
});

describe("registerAuth", () => {
  const ORIGINAL_ENV = process.env.RAGED_API_TOKEN;

  afterEach(() => {
    if (ORIGINAL_ENV === undefined) {
      delete process.env.RAGED_API_TOKEN;
    } else {
      process.env.RAGED_API_TOKEN = ORIGINAL_ENV;
    }
  });

  it("does not add auth hook when RAGED_API_TOKEN is empty", async () => {
    process.env.RAGED_API_TOKEN = "";
    const app = Fastify();
    registerAuth(app);
    app.post("/test", async () => ({ ok: true }));

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(200);
    expect(res.json()).toEqual({ ok: true });
    await app.close();
  });

  it("allows GET /healthz without auth token", async () => {
    process.env.RAGED_API_TOKEN = "secret-token";
    const app = Fastify();
    registerAuth(app);
    app.get("/healthz", async () => ({ ok: true }));

    const res = await app.inject({
      method: "GET",
      url: "/healthz",
    });

    expect(res.statusCode).toBe(200);
    expect(res.json()).toEqual({ ok: true });
    await app.close();
  });

  it("returns 401 when no Authorization header is provided", async () => {
    process.env.RAGED_API_TOKEN = "secret-token";
    const app = Fastify();
    registerAuth(app);
    app.post("/test", async () => ({ ok: true }));

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(401);
    expect(res.json()).toEqual({ error: "Unauthorized" });
    await app.close();
  });

  it("returns 401 when Authorization header lacks Bearer prefix", async () => {
    process.env.RAGED_API_TOKEN = "secret-token";
    const app = Fastify();
    registerAuth(app);
    app.post("/test", async () => ({ ok: true }));

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
      headers: { authorization: "Basic secret-token" },
    });

    expect(res.statusCode).toBe(401);
    expect(res.json()).toEqual({ error: "Unauthorized" });
    await app.close();
  });

  it("returns 401 when wrong token is provided", async () => {
    process.env.RAGED_API_TOKEN = "secret-token";
    const app = Fastify();
    registerAuth(app);
    app.post("/test", async () => ({ ok: true }));

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
      headers: { authorization: "Bearer wrong-token" },
    });

    expect(res.statusCode).toBe(401);
    expect(res.json()).toEqual({ error: "Unauthorized" });
    await app.close();
  });

  it("allows request with correct token", async () => {
    process.env.RAGED_API_TOKEN = "secret-token";
    const app = Fastify();
    registerAuth(app);
    app.post("/test", async () => ({ ok: true }));

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
      headers: { authorization: "Bearer secret-token" },
    });

    expect(res.statusCode).toBe(200);
    expect(res.json()).toEqual({ ok: true });
    await app.close();
  });
});
```

**Step 3: Run the tests and verify they pass**

```bash
cd api && npx vitest run src/auth.test.ts
```

Expected output:

```
 ✓ src/auth.test.ts (11 tests)

 Test Files  1 passed (1)
      Tests  11 passed (11)
```

**Step 4: Commit**

```bash
git add api/src/auth.ts api/src/auth.test.ts
git commit -m "test: add unit tests for auth module"
```

---

### Task 4: Refactor server.ts — extract ingest service

**Files:**
- Create: `api/src/services/ingest.ts`
- Create: `api/src/services/ingest.test.ts`
- Modify: `api/src/server.ts`

**Step 1: Define interfaces and write the ingest service**

Create `api/src/services/ingest.ts`:

```typescript
import { randomUUID } from "node:crypto";
import { chunkText } from "../chunking.js";

export interface IngestItem {
  id?: string;
  text: string;
  source: string;
  metadata?: Record<string, unknown>;
}

export interface IngestRequest {
  collection?: string;
  items: IngestItem[];
}

export interface IngestResult {
  ok: true;
  upserted: number;
}

export interface UpsertPoint {
  id: string;
  vector: number[];
  payload: Record<string, unknown>;
}

export interface IngestDeps {
  embed: (texts: string[]) => Promise<number[][]>;
  ensureCollection: (name: string) => Promise<void>;
  upsert: (collection: string, points: UpsertPoint[]) => Promise<void>;
  collectionName: (name?: string) => string;
}

export async function ingest(
  request: IngestRequest,
  deps: IngestDeps,
): Promise<IngestResult> {
  const col = deps.collectionName(request.collection);
  await deps.ensureCollection(col);

  const points: UpsertPoint[] = [];
  for (const item of request.items) {
    const baseId = item.id ?? randomUUID();
    const chunks = chunkText(item.text);
    const vectors = await deps.embed(chunks);

    for (let i = 0; i < chunks.length; i++) {
      points.push({
        id: `${baseId}:${i}`,
        vector: vectors[i],
        payload: {
          text: chunks[i],
          source: item.source,
          chunkIndex: i,
          ...(item.metadata ?? {}),
        },
      });
    }
  }

  await deps.upsert(col, points);
  return { ok: true, upserted: points.length };
}
```

**Step 2: Write failing test first, then verify it passes with the implementation**

Create `api/src/services/ingest.test.ts`:

```typescript
import { describe, it, expect, vi } from "vitest";
import { ingest } from "./ingest.js";
import type { IngestDeps, IngestRequest } from "./ingest.js";

function makeDeps(overrides?: Partial<IngestDeps>): IngestDeps {
  return {
    embed: overrides?.embed ?? vi.fn(async (texts: string[]) =>
      texts.map(() => [0.1, 0.2, 0.3])
    ),
    ensureCollection: overrides?.ensureCollection ?? vi.fn(async () => {}),
    upsert: overrides?.upsert ?? vi.fn(async () => {}),
    collectionName: overrides?.collectionName ?? vi.fn((name?: string) => name || "docs"),
  };
}

describe("ingest service", () => {
  it("ensures the collection exists before upserting", async () => {
    const deps = makeDeps();
    const request: IngestRequest = {
      collection: "test-col",
      items: [{ text: "hello", source: "test.txt" }],
    };

    await ingest(request, deps);

    expect(deps.ensureCollection).toHaveBeenCalledWith("test-col");
  });

  it("uses default collection when none specified", async () => {
    const deps = makeDeps();
    const request: IngestRequest = {
      items: [{ text: "hello", source: "test.txt" }],
    };

    await ingest(request, deps);

    expect(deps.collectionName).toHaveBeenCalledWith(undefined);
  });

  it("chunks text and embeds each chunk", async () => {
    const embedMock = vi.fn(async (texts: string[]) =>
      texts.map(() => [0.1, 0.2, 0.3])
    );
    const deps = makeDeps({ embed: embedMock });
    const request: IngestRequest = {
      items: [{ text: "hello world", source: "test.txt" }],
    };

    await ingest(request, deps);

    // "hello world" is short, so it should be a single chunk
    expect(embedMock).toHaveBeenCalledWith(["hello world"]);
  });

  it("upserts points with correct structure", async () => {
    const upsertMock = vi.fn(async () => {});
    const deps = makeDeps({ upsert: upsertMock });
    const request: IngestRequest = {
      collection: "my-col",
      items: [
        {
          id: "doc-1",
          text: "hello world",
          source: "test.txt",
          metadata: { lang: "en" },
        },
      ],
    };

    await ingest(request, deps);

    expect(upsertMock).toHaveBeenCalledWith("my-col", [
      {
        id: "doc-1:0",
        vector: [0.1, 0.2, 0.3],
        payload: {
          text: "hello world",
          source: "test.txt",
          chunkIndex: 0,
          lang: "en",
        },
      },
    ]);
  });

  it("generates UUID when item has no id", async () => {
    const upsertMock = vi.fn(async () => {});
    const deps = makeDeps({ upsert: upsertMock });
    const request: IngestRequest = {
      items: [{ text: "hello", source: "test.txt" }],
    };

    await ingest(request, deps);

    const points = upsertMock.mock.calls[0][1];
    // Should have a UUID-like format: <uuid>:0
    expect(points[0].id).toMatch(/^.+:0$/);
    expect(points[0].id.length).toBeGreaterThan(3);
  });

  it("returns the count of upserted points", async () => {
    const deps = makeDeps();
    const request: IngestRequest = {
      items: [
        { text: "item one", source: "a.txt" },
        { text: "item two", source: "b.txt" },
      ],
    };

    const result = await ingest(request, deps);

    expect(result).toEqual({ ok: true, upserted: 2 });
  });

  it("handles multiple items with multiple chunks each", async () => {
    const embedMock = vi.fn(async (texts: string[]) =>
      texts.map(() => [0.1, 0.2, 0.3])
    );
    const upsertMock = vi.fn(async () => {});
    const deps = makeDeps({ embed: embedMock, upsert: upsertMock });

    // Create text long enough to produce 2 chunks
    const longText = Array.from({ length: 30 }, (_, i) =>
      `Line ${i}: ${"x".repeat(80)}`
    ).join("\n");

    const request: IngestRequest = {
      items: [
        { id: "doc-a", text: longText, source: "a.txt" },
        { id: "doc-b", text: "short", source: "b.txt" },
      ],
    };

    const result = await ingest(request, deps);

    // doc-a should produce multiple chunks, doc-b should produce 1
    expect(result.upserted).toBeGreaterThan(2);

    const points = upsertMock.mock.calls[0][1];
    // Verify chunk indices are sequential per document
    const docAPoints = points.filter((p: { id: string }) => p.id.startsWith("doc-a:"));
    for (let i = 0; i < docAPoints.length; i++) {
      expect(docAPoints[i].id).toBe(`doc-a:${i}`);
    }
  });

  it("spreads item metadata into point payload", async () => {
    const upsertMock = vi.fn(async () => {});
    const deps = makeDeps({ upsert: upsertMock });
    const request: IngestRequest = {
      items: [
        {
          id: "doc-1",
          text: "hello",
          source: "test.txt",
          metadata: { repoId: "my-repo", path: "src/test.txt", lang: "ts", bytes: 100 },
        },
      ],
    };

    await ingest(request, deps);

    const points = upsertMock.mock.calls[0][1];
    expect(points[0].payload).toEqual({
      text: "hello",
      source: "test.txt",
      chunkIndex: 0,
      repoId: "my-repo",
      path: "src/test.txt",
      lang: "ts",
      bytes: 100,
    });
  });
});
```

**Step 3: Run the tests and verify they pass**

```bash
cd api && npx vitest run src/services/ingest.test.ts
```

Expected output:

```
 ✓ src/services/ingest.test.ts (8 tests)

 Test Files  1 passed (1)
      Tests  8 passed (8)
```

**Step 4: Update `api/src/server.ts` to use the ingest service**

Replace the current server.ts with:

```typescript
import Fastify from "fastify";
import { ensureCollection, qdrant, collectionName } from "./qdrant.js";
import { embed } from "./ollama.js";
import { registerAuth } from "./auth.js";
import { ingest } from "./services/ingest.js";
import { query } from "./services/query.js";
import type { IngestRequest } from "./services/ingest.js";
import type { QueryRequest } from "./services/query.js";

export function buildApp() {
  const app = Fastify({ logger: true });
  registerAuth(app);

  app.get("/healthz", async () => ({ ok: true }));

  app.post("/ingest", async (req) => {
    const body = req.body as IngestRequest;
    return ingest(body, {
      embed,
      ensureCollection,
      upsert: async (collection, points) => {
        await qdrant.upsert(collection, { wait: true, points });
      },
      collectionName,
    });
  });

  app.post("/query", async (req) => {
    const body = req.body as QueryRequest;
    return query(body, {
      embed,
      ensureCollection,
      search: async (collection, vector, limit, filter) => {
        const res = await qdrant.search(collection, {
          vector,
          limit,
          with_payload: true,
          filter,
        });
        return (res ?? []).map((r) => ({
          id: r.id,
          score: r.score,
          payload: r.payload as Record<string, unknown> | undefined,
        }));
      },
      collectionName,
    });
  });

  return app;
}

const PORT = Number(process.env.PORT || "8080");
const app = buildApp();
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

> **Note:** This references `./services/query.js` which will be created in Task 5. Do NOT commit yet — complete Task 5 first, then commit both together.

**Step 5: Verify all tests still pass**

```bash
cd api && npx vitest run
```

Expected: All chunking, auth, and ingest service tests pass.

**Step 6: Commit** (after Task 5 is complete)

Deferred to Task 5 step 6.

---

### Task 5: Refactor server.ts — extract query service

**Files:**
- Create: `api/src/services/query.ts`
- Create: `api/src/services/query.test.ts`

**Step 1: Write the query service**

Create `api/src/services/query.ts`:

```typescript
export interface QueryRequest {
  collection?: string;
  query: string;
  topK?: number;
  filter?: Record<string, unknown>;
}

export interface QueryResultItem {
  id: string | number;
  score: number;
  source?: string;
  text?: string;
  payload?: Record<string, unknown>;
}

export interface QueryResult {
  ok: true;
  results: QueryResultItem[];
}

export interface SearchHit {
  id: string | number;
  score: number;
  payload?: Record<string, unknown>;
}

export interface QueryDeps {
  embed: (texts: string[]) => Promise<number[][]>;
  ensureCollection: (name: string) => Promise<void>;
  search: (
    collection: string,
    vector: number[],
    limit: number,
    filter?: Record<string, unknown>,
  ) => Promise<SearchHit[]>;
  collectionName: (name?: string) => string;
}

export async function query(
  request: QueryRequest,
  deps: QueryDeps,
): Promise<QueryResult> {
  const col = deps.collectionName(request.collection);
  await deps.ensureCollection(col);

  const [vector] = await deps.embed([request.query]);
  const topK = request.topK ?? 8;

  const hits = await deps.search(col, vector, topK, request.filter);

  const results: QueryResultItem[] = hits.map((hit) => ({
    id: hit.id,
    score: hit.score,
    source: hit.payload?.source as string | undefined,
    text: hit.payload?.text as string | undefined,
    payload: hit.payload,
  }));

  return { ok: true, results };
}
```

**Step 2: Write tests for the query service**

Create `api/src/services/query.test.ts`:

```typescript
import { describe, it, expect, vi } from "vitest";
import { query } from "./query.js";
import type { QueryDeps, QueryRequest, SearchHit } from "./query.js";

function makeDeps(overrides?: Partial<QueryDeps>): QueryDeps {
  return {
    embed: overrides?.embed ?? vi.fn(async (texts: string[]) =>
      texts.map(() => [0.1, 0.2, 0.3])
    ),
    ensureCollection: overrides?.ensureCollection ?? vi.fn(async () => {}),
    search: overrides?.search ?? vi.fn(async () => []),
    collectionName: overrides?.collectionName ?? vi.fn((name?: string) => name || "docs"),
  };
}

describe("query service", () => {
  it("ensures the collection exists before searching", async () => {
    const deps = makeDeps();
    const request: QueryRequest = {
      collection: "test-col",
      query: "hello",
    };

    await query(request, deps);

    expect(deps.ensureCollection).toHaveBeenCalledWith("test-col");
  });

  it("uses default collection when none specified", async () => {
    const deps = makeDeps();
    const request: QueryRequest = { query: "hello" };

    await query(request, deps);

    expect(deps.collectionName).toHaveBeenCalledWith(undefined);
  });

  it("embeds the query text", async () => {
    const embedMock = vi.fn(async () => [[0.1, 0.2, 0.3]]);
    const deps = makeDeps({ embed: embedMock });
    const request: QueryRequest = { query: "authentication flow" };

    await query(request, deps);

    expect(embedMock).toHaveBeenCalledWith(["authentication flow"]);
  });

  it("passes topK to search", async () => {
    const searchMock = vi.fn(async () => []);
    const deps = makeDeps({ search: searchMock });
    const request: QueryRequest = { query: "hello", topK: 5 };

    await query(request, deps);

    expect(searchMock).toHaveBeenCalledWith("docs", [0.1, 0.2, 0.3], 5, undefined);
  });

  it("defaults topK to 8", async () => {
    const searchMock = vi.fn(async () => []);
    const deps = makeDeps({ search: searchMock });
    const request: QueryRequest = { query: "hello" };

    await query(request, deps);

    expect(searchMock).toHaveBeenCalledWith("docs", [0.1, 0.2, 0.3], 8, undefined);
  });

  it("passes filter to search", async () => {
    const searchMock = vi.fn(async () => []);
    const deps = makeDeps({ search: searchMock });
    const filter = { must: [{ key: "repoId", match: { value: "my-repo" } }] };
    const request: QueryRequest = { query: "hello", filter };

    await query(request, deps);

    expect(searchMock).toHaveBeenCalledWith("docs", [0.1, 0.2, 0.3], 8, filter);
  });

  it("maps search hits to result format", async () => {
    const hits: SearchHit[] = [
      {
        id: "doc-1:0",
        score: 0.95,
        payload: {
          text: "hello world",
          source: "test.txt",
          chunkIndex: 0,
          lang: "en",
        },
      },
      {
        id: "doc-2:1",
        score: 0.80,
        payload: {
          text: "foo bar",
          source: "other.txt",
          chunkIndex: 1,
        },
      },
    ];
    const deps = makeDeps({ search: vi.fn(async () => hits) });
    const request: QueryRequest = { query: "hello" };

    const result = await query(request, deps);

    expect(result).toEqual({
      ok: true,
      results: [
        {
          id: "doc-1:0",
          score: 0.95,
          source: "test.txt",
          text: "hello world",
          payload: { text: "hello world", source: "test.txt", chunkIndex: 0, lang: "en" },
        },
        {
          id: "doc-2:1",
          score: 0.80,
          source: "other.txt",
          text: "foo bar",
          payload: { text: "foo bar", source: "other.txt", chunkIndex: 1 },
        },
      ],
    });
  });

  it("returns empty results when no hits", async () => {
    const deps = makeDeps({ search: vi.fn(async () => []) });
    const request: QueryRequest = { query: "nothing" };

    const result = await query(request, deps);

    expect(result).toEqual({ ok: true, results: [] });
  });
});
```

**Step 3: Run the query service tests**

```bash
cd api && npx vitest run src/services/query.test.ts
```

Expected output:

```
 ✓ src/services/query.test.ts (8 tests)

 Test Files  1 passed (1)
      Tests  8 passed (8)
```

**Step 4: Verify ALL tests pass (including server.ts changes from Task 4)**

```bash
cd api && npx vitest run
```

Expected: All tests pass (chunking: 10, auth: 11, ingest: 8, query: 8 = 37 tests).

**Step 5: Verify the build still works**

```bash
cd api && npx tsc --noEmit
```

Expected: No errors.

**Step 6: Commit Tasks 4 + 5 together**

```bash
git add api/src/services/ingest.ts api/src/services/ingest.test.ts api/src/services/query.ts api/src/services/query.test.ts api/src/server.ts
git commit -m "refactor: extract ingest and query logic into service modules"
```

---

### Task 6: Add JSON Schema validation to /ingest

**Files:**
- Modify: `api/src/server.ts`
- Create: `api/src/schemas.ts`

**Step 1: Create the schemas module**

Create `api/src/schemas.ts`:

```typescript
export const ingestSchema = {
  body: {
    type: "object" as const,
    required: ["items"],
    properties: {
      collection: { type: "string" as const },
      items: {
        type: "array" as const,
        minItems: 1,
        items: {
          type: "object" as const,
          required: ["text", "source"],
          properties: {
            id: { type: "string" as const },
            text: { type: "string" as const, minLength: 1 },
            source: { type: "string" as const, minLength: 1 },
            metadata: { type: "object" as const },
          },
        },
      },
    },
  },
};

export const querySchema = {
  body: {
    type: "object" as const,
    required: ["query"],
    properties: {
      collection: { type: "string" as const },
      query: { type: "string" as const, minLength: 1 },
      topK: { type: "integer" as const, minimum: 1, maximum: 100 },
      filter: { type: "object" as const },
    },
  },
};
```

**Step 2: Update `api/src/server.ts` to use schemas**

Update the `buildApp` function to include schema validation on routes. The full updated `api/src/server.ts`:

```typescript
import Fastify from "fastify";
import { ensureCollection, qdrant, collectionName } from "./qdrant.js";
import { embed } from "./ollama.js";
import { registerAuth } from "./auth.js";
import { ingest } from "./services/ingest.js";
import { query } from "./services/query.js";
import { ingestSchema, querySchema } from "./schemas.js";
import type { IngestRequest } from "./services/ingest.js";
import type { QueryRequest } from "./services/query.js";

export function buildApp() {
  const app = Fastify({ logger: true });
  registerAuth(app);

  app.get("/healthz", async () => ({ ok: true }));

  app.post("/ingest", { schema: ingestSchema }, async (req) => {
    const body = req.body as IngestRequest;
    return ingest(body, {
      embed,
      ensureCollection,
      upsert: async (collection, points) => {
        await qdrant.upsert(collection, { wait: true, points });
      },
      collectionName,
    });
  });

  app.post("/query", { schema: querySchema }, async (req) => {
    const body = req.body as QueryRequest;
    return query(body, {
      embed,
      ensureCollection,
      search: async (collection, vector, limit, filter) => {
        const res = await qdrant.search(collection, {
          vector,
          limit,
          with_payload: true,
          filter,
        });
        return (res ?? []).map((r) => ({
          id: r.id,
          score: r.score,
          payload: r.payload as Record<string, unknown> | undefined,
        }));
      },
      collectionName,
    });
  });

  return app;
}

const PORT = Number(process.env.PORT || "8080");
const app = buildApp();
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

**Step 3: Write validation tests**

Create `api/src/schemas.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import Fastify from "fastify";
import { ingestSchema, querySchema } from "./schemas.js";

describe("ingest schema validation", () => {
  function buildApp() {
    const app = Fastify();
    app.post("/ingest", { schema: ingestSchema }, async (req) => {
      return { ok: true };
    });
    return app;
  }

  it("rejects request without items", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {},
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects request with empty items array", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: { items: [] },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects item without text", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {
        items: [{ source: "test.txt" }],
      },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects item without source", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {
        items: [{ text: "hello" }],
      },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects item with empty text", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {
        items: [{ text: "", source: "test.txt" }],
      },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("accepts valid ingest request", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {
        items: [{ text: "hello world", source: "test.txt" }],
      },
    });
    expect(res.statusCode).toBe(200);
    await app.close();
  });

  it("accepts valid ingest request with optional fields", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {
        collection: "my-col",
        items: [
          {
            id: "doc-1",
            text: "hello world",
            source: "test.txt",
            metadata: { lang: "en" },
          },
        ],
      },
    });
    expect(res.statusCode).toBe(200);
    await app.close();
  });
});

describe("query schema validation", () => {
  function buildApp() {
    const app = Fastify();
    app.post("/query", { schema: querySchema }, async (req) => {
      return { ok: true };
    });
    return app;
  }

  it("rejects request without query", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/query",
      payload: {},
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects request with empty query string", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/query",
      payload: { query: "" },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects topK of 0", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/query",
      payload: { query: "hello", topK: 0 },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("rejects topK over 100", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/query",
      payload: { query: "hello", topK: 200 },
    });
    expect(res.statusCode).toBe(400);
    await app.close();
  });

  it("accepts valid query request", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/query",
      payload: { query: "authentication flow" },
    });
    expect(res.statusCode).toBe(200);
    await app.close();
  });

  it("accepts valid query request with all optional fields", async () => {
    const app = buildApp();
    const res = await app.inject({
      method: "POST",
      url: "/query",
      payload: {
        collection: "my-col",
        query: "auth flow",
        topK: 5,
        filter: { must: [{ key: "lang", match: { value: "ts" } }] },
      },
    });
    expect(res.statusCode).toBe(200);
    await app.close();
  });
});
```

**Step 4: Run the schema tests**

```bash
cd api && npx vitest run src/schemas.test.ts
```

Expected output:

```
 ✓ src/schemas.test.ts (13 tests)

 Test Files  1 passed (1)
      Tests  13 passed (13)
```

**Step 5: Verify all tests pass**

```bash
cd api && npx vitest run
```

**Step 6: Commit**

```bash
git add api/src/schemas.ts api/src/schemas.test.ts api/src/server.ts
git commit -m "feat: add JSON Schema validation for /ingest and /query routes"
```

---

### Task 7: Structured error handling

**Files:**
- Create: `api/src/errors.ts`
- Create: `api/src/errors.test.ts`
- Modify: `api/src/server.ts`

**Step 1: Create the error handler module**

Create `api/src/errors.ts`:

```typescript
import type { FastifyInstance, FastifyError, FastifyRequest, FastifyReply } from "fastify";

export interface StructuredError {
  error: string;
}

export function registerErrorHandler(app: FastifyInstance): void {
  app.setErrorHandler(
    async (error: FastifyError, _request: FastifyRequest, reply: FastifyReply) => {
      const statusCode = error.statusCode ?? 500;

      // Fastify validation errors (JSON Schema)
      if (error.validation) {
        return reply.code(400).send({
          error: `Validation failed: ${error.message}`,
        });
      }

      // Upstream service errors (Ollama, Qdrant) — surface as 502
      // Prefer discriminators/codes from infrastructure modules over message matching.
      const upstreamError = error as FastifyError & { code?: string };
      if (
        upstreamError.code === "UPSTREAM_SERVICE_ERROR" ||
        upstreamError.name === "UpstreamServiceError"
      ) {
        return reply.code(502).send({
          error: `Upstream service error: ${error.message}`,
        });
      }

      // Auth errors are already handled by auth.ts hook (401)
      // Any other error with a status code
      if (statusCode >= 400 && statusCode < 500) {
        return reply.code(statusCode).send({
          error: error.message,
        });
      }

      // Internal server errors — do NOT expose stack traces
      app.log.error(error);
      return reply.code(500).send({
        error: "Internal server error",
      });
    },
  );
}
```

**Step 2: Write tests for error handling**

Create `api/src/errors.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import Fastify from "fastify";
import { registerErrorHandler } from "./errors.js";

describe("registerErrorHandler", () => {
  it("returns 400 with structured error for validation failures", async () => {
    const app = Fastify();
    registerErrorHandler(app);
    app.post(
      "/test",
      {
        schema: {
          body: {
            type: "object" as const,
            required: ["name"],
            properties: { name: { type: "string" as const } },
          },
        },
      },
      async () => ({ ok: true }),
    );

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(400);
    const body = res.json();
    expect(body).toHaveProperty("error");
    expect(body.error).toContain("Validation failed");
    await app.close();
  });

  it("returns 502 for Ollama errors", async () => {
    const app = Fastify();
    registerErrorHandler(app);
    app.post("/test", async () => {
      const err = new Error("Ollama embeddings failed: 503 Service Unavailable") as Error & {
        code?: string;
      };
      err.code = "UPSTREAM_SERVICE_ERROR";
      throw err;
    });

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(502);
    const body = res.json();
    expect(body.error).toContain("Upstream service error");
    expect(body.error).toContain("Ollama");
    await app.close();
  });

  it("returns 502 for Qdrant errors", async () => {
    const app = Fastify();
    registerErrorHandler(app);
    app.post("/test", async () => {
      const err = new Error("Qdrant connection failed") as Error & { code?: string };
      err.code = "UPSTREAM_SERVICE_ERROR";
      throw err;
    });

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(502);
    const body = res.json();
    expect(body.error).toContain("Upstream service error");
    expect(body.error).toContain("Qdrant");
    await app.close();
  });

  it("returns 502 for typed upstream transport errors", async () => {
    const app = Fastify();
    registerErrorHandler(app);
    app.post("/test", async () => {
      const err = new Error("connect ECONNREFUSED 127.0.0.1:6333") as Error & {
        code?: string;
      };
      err.code = "UPSTREAM_SERVICE_ERROR";
      throw err;
    });

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(502);
    const body = res.json();
    expect(body.error).toContain("Upstream service error");
    await app.close();
  });

  it("returns 500 with generic message for unknown errors", async () => {
    const app = Fastify({ logger: false });
    registerErrorHandler(app);
    app.post("/test", async () => {
      throw new Error("something unexpected happened with a stack trace");
    });

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(500);
    const body = res.json();
    expect(body).toEqual({ error: "Internal server error" });
    // Should NOT expose the internal message
    expect(body.error).not.toContain("stack trace");
    await app.close();
  });

  it("preserves 4xx status codes from explicit errors", async () => {
    const app = Fastify();
    registerErrorHandler(app);
    app.post("/test", async (_req, reply) => {
      const err = new Error("Not Found") as Error & { statusCode: number };
      err.statusCode = 404;
      throw err;
    });

    const res = await app.inject({
      method: "POST",
      url: "/test",
      payload: {},
    });

    expect(res.statusCode).toBe(404);
    const body = res.json();
    expect(body).toEqual({ error: "Not Found" });
    await app.close();
  });
});
```

**Step 3: Run the error tests**

```bash
cd api && npx vitest run src/errors.test.ts
```

Expected output:

```
 ✓ src/errors.test.ts (6 tests)

 Test Files  1 passed (1)
      Tests  6 passed (6)
```

**Step 4: Register the error handler in `api/src/server.ts`**

Update the `buildApp` function to call `registerErrorHandler`. The full updated file:

```typescript
import Fastify from "fastify";
import { ensureCollection, qdrant, collectionName } from "./qdrant.js";
import { embed } from "./ollama.js";
import { registerAuth } from "./auth.js";
import { registerErrorHandler } from "./errors.js";
import { ingest } from "./services/ingest.js";
import { query } from "./services/query.js";
import { ingestSchema, querySchema } from "./schemas.js";
import type { IngestRequest } from "./services/ingest.js";
import type { QueryRequest } from "./services/query.js";

export function buildApp() {
  const app = Fastify({ logger: true });
  registerAuth(app);
  registerErrorHandler(app);

  app.get("/healthz", async () => ({ ok: true }));

  app.post("/ingest", { schema: ingestSchema }, async (req) => {
    const body = req.body as IngestRequest;
    return ingest(body, {
      embed,
      ensureCollection,
      upsert: async (collection, points) => {
        await qdrant.upsert(collection, { wait: true, points });
      },
      collectionName,
    });
  });

  app.post("/query", { schema: querySchema }, async (req) => {
    const body = req.body as QueryRequest;
    return query(body, {
      embed,
      ensureCollection,
      search: async (collection, vector, limit, filter) => {
        const res = await qdrant.search(collection, {
          vector,
          limit,
          with_payload: true,
          filter,
        });
        return (res ?? []).map((r) => ({
          id: r.id,
          score: r.score,
          payload: r.payload as Record<string, unknown> | undefined,
        }));
      },
      collectionName,
    });
  });

  return app;
}

const PORT = Number(process.env.PORT || "8080");
const app = buildApp();
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

**Step 5: Verify all tests pass**

```bash
cd api && npx vitest run
```

**Step 6: Commit**

```bash
git add api/src/errors.ts api/src/errors.test.ts api/src/server.ts
git commit -m "feat: add structured error handler for validation, upstream, and internal errors"
```

---

### Task 8: Fix sequential embedding — add batched concurrency

**Files:**
- Modify: `api/src/ollama.ts`
- Create: `api/src/ollama.test.ts`

**Step 1: Write the test first (TDD)**

Create `api/src/ollama.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { embed } from "./ollama.js";

// We need to mock global fetch
const originalFetch = globalThis.fetch;

describe("embed", () => {
  let fetchMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    fetchMock = vi.fn();
    globalThis.fetch = fetchMock;
  });

  afterEach(() => {
    globalThis.fetch = originalFetch;
  });

  it("returns embedding vectors for each input text", async () => {
    fetchMock.mockResolvedValue({
      ok: true,
      json: async () => ({ embedding: [0.1, 0.2, 0.3] }),
    });

    const result = await embed(["hello", "world"]);

    expect(result).toEqual([
      [0.1, 0.2, 0.3],
      [0.1, 0.2, 0.3],
    ]);
    expect(fetchMock).toHaveBeenCalledTimes(2);
  });

  it("throws on non-ok response from Ollama", async () => {
    fetchMock.mockResolvedValue({
      ok: false,
      status: 503,
      text: async () => "Service Unavailable",
    });

    await expect(embed(["hello"])).rejects.toThrow("Ollama embeddings failed: 503");
  });

  it("sends correct request body to Ollama API", async () => {
    fetchMock.mockResolvedValue({
      ok: true,
      json: async () => ({ embedding: [0.1] }),
    });

    await embed(["test input"]);

    expect(fetchMock).toHaveBeenCalledWith(
      expect.stringContaining("/api/embeddings"),
      expect.objectContaining({
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ model: "nomic-embed-text", prompt: "test input" }),
      }),
    );
  });

  it("handles empty input array", async () => {
    const result = await embed([]);
    expect(result).toEqual([]);
    expect(fetchMock).not.toHaveBeenCalled();
  });

  it("processes texts in batches with concurrency limit", async () => {
    // Track concurrent requests
    let currentConcurrent = 0;
    let maxConcurrent = 0;

    fetchMock.mockImplementation(async () => {
      currentConcurrent++;
      if (currentConcurrent > maxConcurrent) {
        maxConcurrent = currentConcurrent;
      }
      // Simulate async delay
      await new Promise((r) => setTimeout(r, 10));
      currentConcurrent--;
      return {
        ok: true,
        json: async () => ({ embedding: [0.1] }),
      };
    });

    // Send 25 texts — should be batched, not all at once
    const texts = Array.from({ length: 25 }, (_, i) => `text-${i}`);
    const result = await embed(texts);

    expect(result).toHaveLength(25);
    // Max concurrent should be at most the batch size (10)
    expect(maxConcurrent).toBeLessThanOrEqual(10);
    expect(maxConcurrent).toBeGreaterThan(1); // Verify some parallelism
  });

  it("processes texts with custom concurrency", async () => {
    fetchMock.mockResolvedValue({
      ok: true,
      json: async () => ({ embedding: [0.1] }),
    });

    const texts = Array.from({ length: 5 }, (_, i) => `text-${i}`);
    const result = await embed(texts, 2);

    expect(result).toHaveLength(5);
    expect(fetchMock).toHaveBeenCalledTimes(5);
  });
});
```

**Step 2: Update `api/src/ollama.ts` with batched concurrency**

Replace the entire file:

```typescript
const OLLAMA_URL = process.env.OLLAMA_URL || "http://ollama:11434";
const EMBED_MODEL = process.env.EMBED_MODEL || "nomic-embed-text";

async function embedOne(text: string): Promise<number[]> {
  const res = await fetch(`${OLLAMA_URL}/api/embeddings`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ model: EMBED_MODEL, prompt: text }),
  });
  if (!res.ok) {
    throw new Error(`Ollama embeddings failed: ${res.status} ${await res.text()}`);
  }
  const json = (await res.json()) as { embedding: number[] };
  return json.embedding;
}

export async function embed(texts: string[], concurrency = 10): Promise<number[][]> {
  if (texts.length === 0) return [];
  if (!Number.isInteger(concurrency) || concurrency < 1) {
    throw new Error("concurrency must be a positive integer");
  }

  const results: number[][] = new Array(texts.length);

  for (let i = 0; i < texts.length; i += concurrency) {
    const batch = texts.slice(i, i + concurrency);
    const batchResults = await Promise.all(batch.map((text) => embedOne(text)));
    for (let j = 0; j < batchResults.length; j++) {
      results[i + j] = batchResults[j];
    }
  }

  return results;
}
```

**Step 3: Run the tests**

```bash
cd api && npx vitest run src/ollama.test.ts
```

Expected output:

```
 ✓ src/ollama.test.ts (6 tests)

 Test Files  1 passed (1)
      Tests  6 passed (6)
```

**Step 4: Verify all tests pass**

```bash
cd api && npx vitest run
```

**Step 5: Commit**

```bash
git add api/src/ollama.ts api/src/ollama.test.ts
git commit -m "feat: add batched concurrency to embedding requests (default 10)"
```

---

### Task 9: Unit tests for qdrant.ts

**Files:**
- Create: `api/src/qdrant.test.ts`
- Modify: `api/src/qdrant.ts` (remove `any` cast)

**Step 1: Fix the `any` cast in qdrant.ts**

Update `api/src/qdrant.ts` to remove the `any` cast on DISTANCE:

```typescript
import { QdrantClient } from "@qdrant/js-client-rest";

const QDRANT_URL = process.env.QDRANT_URL || "http://qdrant:6333";
const DEFAULT_COLLECTION = process.env.QDRANT_COLLECTION || "docs";
const VECTOR_SIZE = Number(process.env.VECTOR_SIZE || "768");
const DISTANCE = process.env.DISTANCE || "Cosine";

export const qdrant = new QdrantClient({ url: QDRANT_URL });

export async function ensureCollection(name = DEFAULT_COLLECTION): Promise<void> {
  const collections = await qdrant.getCollections();
  const exists = collections.collections?.some((c) => c.name === name);
  if (exists) return;
  await qdrant.createCollection(name, {
    vectors: { size: VECTOR_SIZE, distance: DISTANCE as "Cosine" | "Euclid" | "Dot" },
  });
}

export function collectionName(name?: string): string {
  return name || DEFAULT_COLLECTION;
}
```

**Step 2: Write tests for `collectionName` (pure function; `ensureCollection` is tested via integration)**

Create `api/src/qdrant.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import { collectionName } from "./qdrant.js";

describe("collectionName", () => {
  it("returns the provided name when given", () => {
    expect(collectionName("my-collection")).toBe("my-collection");
  });

  it("returns the default collection when name is undefined", () => {
    // Default is "docs" from QDRANT_COLLECTION env var or fallback
    expect(collectionName(undefined)).toBe("docs");
  });

  it("returns the default collection when name is empty string", () => {
    expect(collectionName("")).toBe("docs");
  });
});
```

**Step 3: Run the tests**

```bash
cd api && npx vitest run src/qdrant.test.ts
```

Expected output:

```
 ✓ src/qdrant.test.ts (3 tests)

 Test Files  1 passed (1)
      Tests  3 passed (3)
```

**Step 4: Verify all tests pass**

```bash
cd api && npx vitest run
```

**Step 5: Commit**

```bash
git add api/src/qdrant.ts api/src/qdrant.test.ts
git commit -m "refactor: remove any cast in qdrant.ts and add collectionName tests"
```

---

### Task 10: Integration tests for API routes

**Files:**
- Create: `api/src/server.test.ts`

**Step 1: Write integration tests using Fastify inject with mocked dependencies**

Create `api/src/server.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import Fastify from "fastify";
import { registerAuth } from "./auth.js";
import { registerErrorHandler } from "./errors.js";
import { ingest } from "./services/ingest.js";
import { query } from "./services/query.js";
import { ingestSchema, querySchema } from "./schemas.js";
import type { IngestRequest } from "./services/ingest.js";
import type { QueryRequest } from "./services/query.js";
import type { IngestDeps } from "./services/ingest.js";
import type { QueryDeps } from "./services/query.js";

function buildTestApp(options?: {
  ingestDeps?: Partial<IngestDeps>;
  queryDeps?: Partial<QueryDeps>;
}) {
  const app = Fastify({ logger: false });
  registerAuth(app);
  registerErrorHandler(app);

  const defaultIngestDeps: IngestDeps = {
    embed: vi.fn(async (texts: string[]) => texts.map(() => [0.1, 0.2, 0.3])),
    ensureCollection: vi.fn(async () => {}),
    upsert: vi.fn(async () => {}),
    collectionName: vi.fn((name?: string) => name || "docs"),
  };

  const defaultQueryDeps: QueryDeps = {
    embed: vi.fn(async () => [[0.1, 0.2, 0.3]]),
    ensureCollection: vi.fn(async () => {}),
    search: vi.fn(async () => [
      {
        id: "doc-1:0",
        score: 0.9,
        payload: { text: "result text", source: "test.txt", chunkIndex: 0 },
      },
    ]),
    collectionName: vi.fn((name?: string) => name || "docs"),
  };

  const ingestDeps = { ...defaultIngestDeps, ...options?.ingestDeps };
  const queryDeps = { ...defaultQueryDeps, ...options?.queryDeps };

  app.get("/healthz", async () => ({ ok: true }));

  app.post("/ingest", { schema: ingestSchema }, async (req) => {
    const body = req.body as IngestRequest;
    return ingest(body, ingestDeps);
  });

  app.post("/query", { schema: querySchema }, async (req) => {
    const body = req.body as QueryRequest;
    return query(body, queryDeps);
  });

  return { app, ingestDeps, queryDeps };
}

describe("API integration tests", () => {
  describe("GET /healthz", () => {
    it("returns 200 with { ok: true }", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "GET",
        url: "/healthz",
      });

      expect(res.statusCode).toBe(200);
      expect(res.json()).toEqual({ ok: true });
      await app.close();
    });
  });

  describe("POST /ingest", () => {
    it("returns 200 with upsert count for valid request", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        payload: {
          collection: "test-col",
          items: [
            { text: "hello world", source: "test.txt" },
            { text: "foo bar", source: "other.txt" },
          ],
        },
      });

      expect(res.statusCode).toBe(200);
      const body = res.json();
      expect(body.ok).toBe(true);
      expect(body.upserted).toBe(2);
      await app.close();
    });

    it("returns 400 for missing items", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        payload: { collection: "test" },
      });

      expect(res.statusCode).toBe(400);
      expect(res.json()).toHaveProperty("error");
      await app.close();
    });

    it("returns 400 for empty items array", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        payload: { items: [] },
      });

      expect(res.statusCode).toBe(400);
      await app.close();
    });

    it("returns 502 when embed service fails", async () => {
      const { app } = buildTestApp({
        ingestDeps: {
          embed: vi.fn(async () => {
            throw new Error("Ollama embeddings failed: 503 Service Unavailable");
          }),
        },
      });

      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        payload: {
          items: [{ text: "hello", source: "test.txt" }],
        },
      });

      expect(res.statusCode).toBe(502);
      expect(res.json().error).toContain("Upstream service error");
      await app.close();
    });
  });

  describe("POST /query", () => {
    it("returns 200 with results for valid query", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "POST",
        url: "/query",
        payload: {
          query: "authentication flow",
          topK: 5,
        },
      });

      expect(res.statusCode).toBe(200);
      const body = res.json();
      expect(body.ok).toBe(true);
      expect(body.results).toHaveLength(1);
      expect(body.results[0]).toEqual({
        id: "doc-1:0",
        score: 0.9,
        source: "test.txt",
        text: "result text",
        payload: { text: "result text", source: "test.txt", chunkIndex: 0 },
      });
      await app.close();
    });

    it("returns 400 for missing query", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "POST",
        url: "/query",
        payload: { topK: 5 },
      });

      expect(res.statusCode).toBe(400);
      expect(res.json()).toHaveProperty("error");
      await app.close();
    });

    it("returns 400 for empty query string", async () => {
      const { app } = buildTestApp();
      const res = await app.inject({
        method: "POST",
        url: "/query",
        payload: { query: "" },
      });

      expect(res.statusCode).toBe(400);
      await app.close();
    });

    it("returns empty results when search returns nothing", async () => {
      const { app } = buildTestApp({
        queryDeps: {
          search: vi.fn(async () => []),
        },
      });

      const res = await app.inject({
        method: "POST",
        url: "/query",
        payload: { query: "nothing matches" },
      });

      expect(res.statusCode).toBe(200);
      expect(res.json()).toEqual({ ok: true, results: [] });
      await app.close();
    });

    it("passes filter through to search", async () => {
      const searchMock = vi.fn(async () => []);
      const { app } = buildTestApp({
        queryDeps: { search: searchMock },
      });

      const filter = { must: [{ key: "lang", match: { value: "ts" } }] };
      const res = await app.inject({
        method: "POST",
        url: "/query",
        payload: { query: "hello", filter },
      });

      expect(res.statusCode).toBe(200);
      expect(searchMock).toHaveBeenCalledWith(
        "docs",
        [0.1, 0.2, 0.3],
        8,
        filter,
      );
      await app.close();
    });
  });

  describe("auth integration", () => {
    const ORIGINAL_TOKEN = process.env.RAGED_API_TOKEN;

    afterEach(() => {
      if (ORIGINAL_TOKEN === undefined) {
        delete process.env.RAGED_API_TOKEN;
      } else {
        process.env.RAGED_API_TOKEN = ORIGINAL_TOKEN;
      }
    });

    it("blocks /ingest without token when auth is enabled", async () => {
      process.env.RAGED_API_TOKEN = "test-secret";
      const { app } = buildTestApp();

      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        payload: {
          items: [{ text: "hello", source: "test.txt" }],
        },
      });

      expect(res.statusCode).toBe(401);
      expect(res.json()).toEqual({ error: "Unauthorized" });
      await app.close();
    });

    it("allows /ingest with correct token", async () => {
      process.env.RAGED_API_TOKEN = "test-secret";
      const { app } = buildTestApp();

      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        headers: { authorization: "Bearer test-secret" },
        payload: {
          items: [{ text: "hello", source: "test.txt" }],
        },
      });

      expect(res.statusCode).toBe(200);
      await app.close();
    });

    it("always allows /healthz without token", async () => {
      process.env.RAGED_API_TOKEN = "test-secret";
      const { app } = buildTestApp();

      const res = await app.inject({
        method: "GET",
        url: "/healthz",
      });

      expect(res.statusCode).toBe(200);
      expect(res.json()).toEqual({ ok: true });
      await app.close();
    });
  });
});
```

**Step 2: Run integration tests**

```bash
cd api && npx vitest run src/server.test.ts
```

Expected output:

```
 ✓ src/server.test.ts (12 tests)

 Test Files  1 passed (1)
      Tests  12 passed (12)
```

**Step 3: Run ALL tests to verify nothing broke**

```bash
cd api && npx vitest run
```

Expected: All tests pass (chunking: 10, auth: 11, ingest: 8, query: 8, schemas: 13, errors: 6, ollama: 6, qdrant: 3, server: 12 = ~77 tests).

**Step 4: Verify the build**

```bash
cd api && npx tsc --noEmit
```

**Step 5: Commit**

```bash
git add api/src/server.test.ts
git commit -m "test: add integration tests for all API routes with mocked dependencies"
```

---

### Task 11: Update GitHub Actions CI to run tests

**Files:**
- Modify: `.github/workflows/ci.yaml`

**Step 1: Update CI to include test and lint jobs**

Replace the entire contents of `.github/workflows/ci.yaml`:

```yaml
name: CI

on:
  push:
    branches: ["main"]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        pkg: [api, cli]
    defaults:
      run:
        working-directory: ${{ matrix.pkg }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ matrix.pkg }}/package-lock.json
      - name: Install
        run: npm ci
      - name: Build
        run: npm run build

  test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: api
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: api/package-lock.json
      - name: Install
        run: npm ci
      - name: Run tests
        run: npm test

  lint:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        pkg: [api, cli]
    defaults:
      run:
        working-directory: ${{ matrix.pkg }}
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ${{ matrix.pkg }}/package-lock.json
      - name: Install
        run: npm ci
      - name: Type check
        run: npx tsc --noEmit

  docker-build:
    runs-on: ubuntu-latest
    needs: [build, test, lint]
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - name: Build API image (no push)
        uses: docker/build-push-action@v6
        with:
          context: ./api
          push: false
          tags: rag-api:ci
      - name: Build Indexer image (no push)
        uses: docker/build-push-action@v6
        with:
          context: ./cli
          push: false
          tags: raged-index:ci

  helm-lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-helm@v4
        with:
          version: v3.15.4
      - run: helm lint ./chart
```

**Step 2: Verify YAML is valid**

```bash
python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yaml'))" && echo "Valid YAML"
```

Expected: `Valid YAML`

**Step 3: Commit**

```bash
git add .github/workflows/ci.yaml
git commit -m "ci: add test and lint jobs to GitHub Actions workflow"
```

---

### Task 12: Add .env.example

**Files:**
- Create: `.env.example`

**Step 1: Create `.env.example` with all documented env vars**

```bash
# raged environment variables
# Copy to .env and adjust values for local development.
# These are NOT loaded by the application — they document available configuration.

# --- RAG API ---
PORT=8080
RAGED_API_TOKEN=

# --- Qdrant ---
QDRANT_URL=http://localhost:6333
QDRANT_COLLECTION=docs
VECTOR_SIZE=768
DISTANCE=Cosine

# --- Ollama ---
OLLAMA_URL=http://localhost:11434
EMBED_MODEL=nomic-embed-text
```

**Step 2: Verify the file exists and has content**

```bash
head -5 .env.example
```

Expected: First 5 lines of comments/variables visible.

**Step 3: Commit**

```bash
git add .env.example
git commit -m "chore: add .env.example with all documented environment variables"
```

---

### Task 13: Migrate CLI to a proper npm CLI library

**Files:**
- Modify: `cli/package.json`
- Modify: `cli/src/index.ts`

**Step 1: Add a proper CLI framework dependency**

Install `commander` and remove `minimist`:

```bash
cd cli
npm uninstall minimist @types/minimist
npm install commander
```

**Step 2: Refactor argument parsing to Commander**

Replace ad-hoc `minimist` parsing in `cli/src/index.ts` with `commander` subcommands:

- `index` command with explicit typed options (`--repo`, `--api`, `--collection`, `--branch`, `--repoId`, `--token`, `--include`, `--exclude`, `--maxFiles`, `--maxBytes`, `--keep`)
- `query` command with explicit typed options (`--q`, `--api`, `--collection`, `--topK`, `--repoId`, `--pathPrefix`, `--lang`, `--token`)
- built-in help text for all commands/options via commander

Implementation requirements:

- keep `cmdIndex` and `cmdQuery` as thin orchestrator entry functions
- preserve current default values and behavior
- preserve actionable error messages for API failures
- reject unknown commands/options with clear help output

**Step 3: Verify CLI behavior and build**

```bash
cd cli
npm run build
node dist/index.js --help
node dist/index.js index --help
node dist/index.js query --help
```

Expected:

- TypeScript build passes
- top-level help prints command list
- command-level help prints option defaults and descriptions

**Step 4: Commit**

```bash
git add cli/package.json cli/package-lock.json cli/src/index.ts
git commit -m "refactor(cli): migrate argument parsing to commander"
```

---

## Summary

| Task | Files | Type | Tests |
|------|-------|------|-------|
| 1 | `api/package.json`, `api/vitest.config.ts`, `api/tsconfig.json` | Infrastructure | 0 |
| 2 | `api/src/chunking.test.ts` | Test | 10 |
| 3 | `api/src/auth.ts`, `api/src/auth.test.ts` | Test + Refactor | 11 |
| 4 | `api/src/services/ingest.ts`, `api/src/services/ingest.test.ts`, `api/src/server.ts` | Refactor + Test | 8 |
| 5 | `api/src/services/query.ts`, `api/src/services/query.test.ts` | Refactor + Test | 8 |
| 6 | `api/src/schemas.ts`, `api/src/schemas.test.ts`, `api/src/server.ts` | Feature + Test | 13 |
| 7 | `api/src/errors.ts`, `api/src/errors.test.ts`, `api/src/server.ts` | Feature + Test | 6 |
| 8 | `api/src/ollama.ts`, `api/src/ollama.test.ts` | Feature + Test | 6 |
| 9 | `api/src/qdrant.ts`, `api/src/qdrant.test.ts` | Refactor + Test | 3 |
| 10 | `api/src/server.test.ts` | Test | 12 |
| 11 | `.github/workflows/ci.yaml` | CI/CD | 0 |
| 12 | `.env.example` | Docs | 0 |
| 13 | `cli/package.json`, `cli/src/index.ts` | Refactor | 0 |

**13 tasks, 13 commits, ~77 tests total.**

### Violations Fixed

| AGENTS.md Rule | Violation | Fix |
|---------------|-----------|-----|
| Route handlers stay thin (~15 lines) | `/ingest` handler is 18 lines of business logic | Tasks 4-5: Extract to service modules |
| Use Fastify JSON Schema validation | No input validation at all | Task 6: Add schemas for both routes |
| Return structured JSON errors | No error handler, raw stack traces leak | Task 7: Structured error handler |
| No `any` in new code | 6 uses of `any` in server.ts, qdrant.ts | Tasks 4-5, 9: Replace with typed interfaces |
| TDD: Write failing test first | No tests exist | Tasks 2-3, 8-10: Full test coverage |
| Test runner: Vitest | Not installed | Task 1: Add Vitest infrastructure |
| Co-located test files | No test files | All tasks: `<module>.test.ts` pattern |
| CI should run tests | CI only builds, no tests | Task 11: Add test + lint jobs |
| Named exports only | `timingSafeEqual` not exported | Task 3: Export for testing |
| Dependency Inversion | Handlers call infrastructure directly | Tasks 4-5: Dependency injection via interfaces |
| CLI maintainability and explicit help | `minimist` parsing is manual and loosely typed | Task 13: Migrate to `commander` subcommands/options |
