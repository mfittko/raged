# v1.0 Production Hardening Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Harden rag-stack for production use with embedding provider adapters, vector backend adapters, rate limiting, structured logging, and API versioning.

**Architecture:** Introduce adapter interfaces for embedding and vector backends, allowing swappable implementations. Add request rate limiting, structured JSON logging with correlation IDs, and versioned API routes.

**Tech Stack:** TypeScript, Fastify, Vitest, pino (structured logging)

**Depends on:** v0.5 Standards Compliance plan must be complete first (Vitest, service layer, JSON Schema validation already in place).

---

### Task 1: Define EmbeddingProvider interface

**Files:**
- Create: `api/src/interfaces/embedding.ts`
- Create: `api/src/interfaces/embedding.test.ts`

**Step 1: Write the EmbeddingProvider interface**

Create `api/src/interfaces/embedding.ts`:

```typescript
/**
 * Contract for embedding providers.
 * Implementations: OllamaProvider, OpenAIProvider.
 */
export interface EmbeddingProvider {
  /** Embed one or more text strings into vectors. */
  embed(texts: string[]): Promise<number[][]>;
  /** Dimensionality of the vectors this provider produces. */
  readonly dimensions: number;
  /** Human-readable provider name (e.g. "ollama", "openai"). */
  readonly name: string;
}
```

**Step 2: Write a test verifying the interface contract**

Create `api/src/interfaces/embedding.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import type { EmbeddingProvider } from "./embedding.js";

/**
 * Creates a mock EmbeddingProvider for contract testing.
 * Returns fixed 3-dimensional vectors so tests are deterministic.
 */
function createMockProvider(dims: number): EmbeddingProvider {
  return {
    name: "mock",
    dimensions: dims,
    async embed(texts: string[]): Promise<number[][]> {
      return texts.map(() => Array.from({ length: dims }, (_, i) => i * 0.1));
    },
  };
}

describe("EmbeddingProvider interface contract", () => {
  it("embed returns one vector per input text", async () => {
    const provider = createMockProvider(3);
    const result = await provider.embed(["hello", "world"]);

    expect(result).toHaveLength(2);
    expect(result[0]).toHaveLength(3);
    expect(result[1]).toHaveLength(3);
  });

  it("dimensions matches the length of returned vectors", async () => {
    const provider = createMockProvider(768);
    const result = await provider.embed(["test"]);

    expect(result[0]).toHaveLength(provider.dimensions);
  });

  it("name returns a non-empty string", () => {
    const provider = createMockProvider(3);

    expect(provider.name).toBe("mock");
    expect(provider.name.length).toBeGreaterThan(0);
  });

  it("embed returns empty array for empty input", async () => {
    const provider = createMockProvider(3);
    const result = await provider.embed([]);

    expect(result).toEqual([]);
  });
});
```

**Step 3: Run the test to verify it passes**

```bash
cd api && npx vitest run src/interfaces/embedding.test.ts
```

Expected: 4 tests pass.

**Step 4: Commit**

```bash
git add api/src/interfaces/embedding.ts api/src/interfaces/embedding.test.ts
git commit -m "feat: define EmbeddingProvider interface with contract tests"
```

---

### Task 2: Refactor Ollama to implement EmbeddingProvider

**Files:**
- Modify: `api/src/ollama.ts`
- Create: `api/src/ollama.test.ts`

**Step 1: Write the failing test**

Create `api/src/ollama.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { createOllamaProvider } from "./ollama.js";
import type { EmbeddingProvider } from "./interfaces/embedding.js";

describe("OllamaProvider", () => {
  let provider: EmbeddingProvider;

  beforeEach(() => {
    provider = createOllamaProvider({
      url: "http://localhost:11434",
      model: "nomic-embed-text",
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("has name 'ollama'", () => {
    expect(provider.name).toBe("ollama");
  });

  it("has dimensions 768", () => {
    expect(provider.dimensions).toBe(768);
  });

  it("embed calls Ollama API for each text and returns vectors", async () => {
    const mockVector = Array.from({ length: 768 }, (_, i) => i * 0.001);
    const fetchSpy = vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(JSON.stringify({ embedding: mockVector }), {
        status: 200,
        headers: { "content-type": "application/json" },
      }),
    );

    const result = await provider.embed(["hello", "world"]);

    expect(fetchSpy).toHaveBeenCalledTimes(2);
    expect(result).toHaveLength(2);
    expect(result[0]).toEqual(mockVector);
    expect(result[1]).toEqual(mockVector);

    // Verify the request shape
    const [url, options] = fetchSpy.mock.calls[0] as [string, RequestInit];
    expect(url).toBe("http://localhost:11434/api/embeddings");
    expect(JSON.parse(options.body as string)).toEqual({
      model: "nomic-embed-text",
      prompt: "hello",
    });
  });

  it("embed throws on non-OK response", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response("model not found", { status: 404 }),
    );

    await expect(provider.embed(["test"])).rejects.toThrow(
      /Ollama embeddings failed: 404/,
    );
  });

  it("embed returns empty array for empty input", async () => {
    const fetchSpy = vi.spyOn(globalThis, "fetch");
    const result = await provider.embed([]);

    expect(fetchSpy).not.toHaveBeenCalled();
    expect(result).toEqual([]);
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/ollama.test.ts
```

Expected: FAIL — `createOllamaProvider` is not exported from `./ollama.js`.

**Step 3: Implement — refactor ollama.ts**

Replace `api/src/ollama.ts` with:

```typescript
import type { EmbeddingProvider } from "./interfaces/embedding.js";

export interface OllamaProviderOptions {
  url?: string;
  model?: string;
  dimensions?: number;
}

/**
 * Create an EmbeddingProvider backed by Ollama's /api/embeddings endpoint.
 */
export function createOllamaProvider(
  options: OllamaProviderOptions = {},
): EmbeddingProvider {
  const ollamaUrl = options.url ?? process.env.OLLAMA_URL ?? "http://ollama:11434";
  const model = options.model ?? process.env.EMBED_MODEL ?? "nomic-embed-text";
  const dims = options.dimensions ?? Number(process.env.VECTOR_SIZE || "768");

  return {
    name: "ollama",
    dimensions: dims,

    async embed(texts: string[]): Promise<number[][]> {
      if (texts.length === 0) {
        return [];
      }

      const vectors: number[][] = [];
      for (const input of texts) {
        const res = await fetch(`${ollamaUrl}/api/embeddings`, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ model, prompt: input }),
        });
        if (!res.ok) {
          throw new Error(
            `Ollama embeddings failed: ${res.status} ${await res.text()}`,
          );
        }
        const json: unknown = await res.json();
        const parsed = json as { embedding: number[] };
        vectors.push(parsed.embedding);
      }
      return vectors;
    },
  };
}

/**
 * Legacy function — maintained for backward compatibility during transition.
 * Prefer createOllamaProvider() for new code.
 */
export async function embed(texts: string[]): Promise<number[][]> {
  const provider = createOllamaProvider();
  return provider.embed(texts);
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/ollama.test.ts
```

Expected: 5 tests pass.

**Step 5: Commit**

```bash
git add api/src/ollama.ts api/src/ollama.test.ts
git commit -m "refactor: extract OllamaProvider implementing EmbeddingProvider interface"
```

---

### Task 3: Add OpenAI embedding provider

**Files:**
- Create: `api/src/providers/openai-embeddings.ts`
- Create: `api/src/providers/openai-embeddings.test.ts`

**Step 1: Write the failing test**

Create `api/src/providers/openai-embeddings.test.ts`:

```typescript
import { describe, it, expect, vi, afterEach } from "vitest";
import { createOpenAIProvider } from "./openai-embeddings.js";

describe("OpenAIProvider", () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("has name 'openai'", () => {
    const provider = createOpenAIProvider({ apiKey: "test-key" });
    expect(provider.name).toBe("openai");
  });

  it("has dimensions 1536 by default (text-embedding-3-small)", () => {
    const provider = createOpenAIProvider({ apiKey: "test-key" });
    expect(provider.dimensions).toBe(1536);
  });

  it("embed calls OpenAI API and returns vectors", async () => {
    const mockVector1 = Array.from({ length: 1536 }, (_, i) => i * 0.001);
    const mockVector2 = Array.from({ length: 1536 }, (_, i) => i * 0.002);

    const fetchSpy = vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(
        JSON.stringify({
          object: "list",
          data: [
            { object: "embedding", index: 0, embedding: mockVector1 },
            { object: "embedding", index: 1, embedding: mockVector2 },
          ],
          usage: { prompt_tokens: 10, total_tokens: 10 },
        }),
        { status: 200, headers: { "content-type": "application/json" } },
      ),
    );

    const provider = createOpenAIProvider({ apiKey: "sk-test-key" });
    const result = await provider.embed(["hello", "world"]);

    expect(fetchSpy).toHaveBeenCalledTimes(1);
    expect(result).toHaveLength(2);
    expect(result[0]).toEqual(mockVector1);
    expect(result[1]).toEqual(mockVector2);

    // Verify request shape
    const [url, options] = fetchSpy.mock.calls[0] as [string, RequestInit];
    expect(url).toBe("https://api.openai.com/v1/embeddings");
    const body = JSON.parse(options.body as string);
    expect(body).toEqual({
      model: "text-embedding-3-small",
      input: ["hello", "world"],
    });
    expect((options.headers as Record<string, string>)["Authorization"]).toBe(
      "Bearer sk-test-key",
    );
  });

  it("embed throws on non-OK response", async () => {
    vi.spyOn(globalThis, "fetch").mockResolvedValue(
      new Response(JSON.stringify({ error: { message: "invalid api key" } }), {
        status: 401,
      }),
    );

    const provider = createOpenAIProvider({ apiKey: "bad-key" });
    await expect(provider.embed(["test"])).rejects.toThrow(
      /OpenAI embeddings failed: 401/,
    );
  });

  it("embed returns empty array for empty input", async () => {
    const fetchSpy = vi.spyOn(globalThis, "fetch");
    const provider = createOpenAIProvider({ apiKey: "test-key" });
    const result = await provider.embed([]);

    expect(fetchSpy).not.toHaveBeenCalled();
    expect(result).toEqual([]);
  });

  it("throws if no API key provided", () => {
    expect(() => createOpenAIProvider({ apiKey: "" })).toThrow(
      /OPENAI_API_KEY is required/,
    );
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/providers/openai-embeddings.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement**

Create `api/src/providers/openai-embeddings.ts`:

```typescript
import type { EmbeddingProvider } from "../interfaces/embedding.js";

export interface OpenAIProviderOptions {
  apiKey?: string;
  model?: string;
  dimensions?: number;
  baseUrl?: string;
}

interface OpenAIEmbeddingResponse {
  object: string;
  data: Array<{ object: string; index: number; embedding: number[] }>;
  usage: { prompt_tokens: number; total_tokens: number };
}

/**
 * Create an EmbeddingProvider backed by the OpenAI embeddings API.
 * Uses text-embedding-3-small (1536 dimensions) by default.
 */
export function createOpenAIProvider(
  options: OpenAIProviderOptions = {},
): EmbeddingProvider {
  const apiKey = options.apiKey ?? process.env.OPENAI_API_KEY ?? "";
  if (!apiKey) {
    throw new Error("OPENAI_API_KEY is required for the OpenAI embedding provider");
  }

  const model = options.model ?? "text-embedding-3-small";
  const dims = options.dimensions ?? 1536;
  const baseUrl = options.baseUrl ?? "https://api.openai.com";

  return {
    name: "openai",
    dimensions: dims,

    async embed(texts: string[]): Promise<number[][]> {
      if (texts.length === 0) return [];

      const res = await fetch(`${baseUrl}/v1/embeddings`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ model, input: texts }),
      });

      if (!res.ok) {
        throw new Error(
          `OpenAI embeddings failed: ${res.status} ${await res.text()}`,
        );
      }

      const json: unknown = await res.json();
      const parsed = json as OpenAIEmbeddingResponse;

      // OpenAI returns embeddings sorted by index, but sort defensively
      const sorted = [...parsed.data].sort((a, b) => a.index - b.index);
      return sorted.map((item) => item.embedding);
    },
  };
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/providers/openai-embeddings.test.ts
```

Expected: 6 tests pass.

**Step 5: Commit**

```bash
git add api/src/providers/openai-embeddings.ts api/src/providers/openai-embeddings.test.ts
git commit -m "feat: add OpenAI embedding provider implementing EmbeddingProvider"
```

---

### Task 4: Provider factory and configuration

**Files:**
- Create: `api/src/providers/embedding-factory.ts`
- Create: `api/src/providers/embedding-factory.test.ts`
- Modify: `api/src/services/ingest.ts`
- Modify: `api/src/services/query.ts`
- Modify: `api/src/server.ts`

**Step 1: Write the failing test**

Create `api/src/providers/embedding-factory.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { createEmbeddingProvider } from "./embedding-factory.js";

describe("createEmbeddingProvider", () => {
  const originalEnv = process.env;

  beforeEach(() => {
    process.env = { ...originalEnv };
  });

  afterEach(() => {
    process.env = originalEnv;
    vi.restoreAllMocks();
  });

  it("returns OllamaProvider when EMBED_PROVIDER is 'ollama'", () => {
    process.env.EMBED_PROVIDER = "ollama";
    const provider = createEmbeddingProvider();

    expect(provider.name).toBe("ollama");
    expect(provider.dimensions).toBe(768);
  });

  it("returns OllamaProvider by default when EMBED_PROVIDER is not set", () => {
    delete process.env.EMBED_PROVIDER;
    const provider = createEmbeddingProvider();

    expect(provider.name).toBe("ollama");
  });

  it("returns OpenAIProvider when EMBED_PROVIDER is 'openai'", () => {
    process.env.EMBED_PROVIDER = "openai";
    process.env.OPENAI_API_KEY = "sk-test-key";
    const provider = createEmbeddingProvider();

    expect(provider.name).toBe("openai");
    expect(provider.dimensions).toBe(1536);
  });

  it("throws for unknown provider", () => {
    process.env.EMBED_PROVIDER = "cohere";
    expect(() => createEmbeddingProvider()).toThrow(
      /Unknown embedding provider: "cohere"/,
    );
  });

  it("throws when openai is selected but no API key", () => {
    process.env.EMBED_PROVIDER = "openai";
    delete process.env.OPENAI_API_KEY;
    expect(() => createEmbeddingProvider()).toThrow(/OPENAI_API_KEY is required/);
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/providers/embedding-factory.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement the factory**

Create `api/src/providers/embedding-factory.ts`:

```typescript
import type { EmbeddingProvider } from "../interfaces/embedding.js";
import { createOllamaProvider } from "../ollama.js";
import { createOpenAIProvider } from "./openai-embeddings.js";

/**
 * Create an EmbeddingProvider based on the EMBED_PROVIDER environment variable.
 * Supported values: "ollama" (default), "openai".
 */
export function createEmbeddingProvider(): EmbeddingProvider {
  const providerName = (process.env.EMBED_PROVIDER ?? "ollama").toLowerCase();

  switch (providerName) {
    case "ollama":
      return createOllamaProvider();
    case "openai":
      return createOpenAIProvider();
    default:
      throw new Error(
        `Unknown embedding provider: "${providerName}". Supported: ollama, openai`,
      );
  }
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/providers/embedding-factory.test.ts
```

Expected: 5 tests pass.

**Step 5: Wire the factory into server.ts**

Update `api/src/server.ts` to use the provider factory. Replace the import and usage of the legacy `embed` function:

```typescript
import Fastify from "fastify";
import { randomUUID } from "node:crypto";
import { ensureCollection, qdrant, collectionName } from "./qdrant.js";
import { createEmbeddingProvider } from "./providers/embedding-factory.js";
import { chunkText } from "./chunking.js";
import { registerAuth } from "./auth.js";

const embedder = createEmbeddingProvider();

const app = Fastify({ logger: true });
registerAuth(app);

app.get("/healthz", async () => ({ ok: true }));

app.post("/ingest", async (req: unknown) => {
  const body = (req as { body: { collection?: string; items: Array<{ id?: string; text: string; source: string; metadata?: Record<string, unknown> }> } }).body;
  const col = collectionName(body.collection);
  await ensureCollection(col);

  const points: Array<{ id: string; vector: number[]; payload: Record<string, unknown> }> = [];
  for (const item of body.items) {
    const baseId = item.id ?? randomUUID();
    const chunks = chunkText(item.text);
    const vectors = await embedder.embed(chunks);

    for (let i = 0; i < chunks.length; i++) {
      points.push({
        id: `${baseId}:${i}`,
        vector: vectors[i],
        payload: { text: chunks[i], source: item.source, chunkIndex: i, ...(item.metadata ?? {}) },
      });
    }
  }
  await qdrant.upsert(col, { wait: true, points });
  return { ok: true, upserted: points.length };
});

app.post("/query", async (req: unknown) => {
  const body = (req as { body: { collection?: string; query: string; topK?: number; filter?: Record<string, unknown> } }).body;
  const col = collectionName(body.collection);
  await ensureCollection(col);

  const [vector] = await embedder.embed([body.query]);
  const topK = body.topK ?? 8;

  const res = await qdrant.search(col, { vector, limit: topK, with_payload: true, filter: body.filter });
  return {
    ok: true,
    results: (res ?? []).map((r: { id: string | number; score: number; payload?: Record<string, unknown> }) => ({
      id: r.id,
      score: r.score,
      source: r.payload?.source,
      text: r.payload?.text,
      payload: r.payload,
    })),
  };
});

const PORT = Number(process.env.PORT || "8080");
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

**Step 6: Run all tests to verify nothing is broken**

```bash
cd api && npx vitest run
```

Expected: All tests pass.

**Step 7: Commit**

```bash
git add api/src/providers/embedding-factory.ts api/src/providers/embedding-factory.test.ts api/src/server.ts
git commit -m "feat: add embedding provider factory, wire into server.ts"
```

---

### Task 5: Define VectorStore interface

**Files:**
- Create: `api/src/interfaces/vector-store.ts`
- Create: `api/src/interfaces/vector-store.test.ts`

**Step 1: Write the VectorStore interface**

Create `api/src/interfaces/vector-store.ts`:

```typescript
/**
 * A single vector point to store.
 */
export interface VectorPoint {
  id: string;
  vector: number[];
  payload: Record<string, unknown>;
}

/**
 * Options for similarity search.
 */
export interface SearchOptions {
  limit: number;
  filter?: Record<string, unknown>;
}

/**
 * A single search result.
 */
export interface SearchResult {
  id: string | number;
  score: number;
  payload: Record<string, unknown>;
}

/**
 * Contract for vector storage backends.
 * Implementations: QdrantStore (more in future: Pinecone, pgvector, etc.)
 */
export interface VectorStore {
  /** Ensure a collection exists with the given name and vector dimensions. */
  ensureCollection(name: string, dimensions: number): Promise<void>;
  /** Upsert (insert or update) vector points into a collection. */
  upsert(collection: string, points: VectorPoint[]): Promise<void>;
  /** Search for the nearest vectors in a collection. */
  search(
    collection: string,
    vector: number[],
    options: SearchOptions,
  ): Promise<SearchResult[]>;
}
```

**Step 2: Write a test verifying the interface contract**

Create `api/src/interfaces/vector-store.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import type {
  VectorStore,
  VectorPoint,
  SearchOptions,
  SearchResult,
} from "./vector-store.js";

/**
 * In-memory VectorStore mock for contract testing.
 * Uses exact dot-product for "similarity" (not cosine, but sufficient for contract tests).
 */
function createMockVectorStore(): VectorStore {
  const collections = new Map<string, { dimensions: number; points: VectorPoint[] }>();

  return {
    async ensureCollection(name: string, dimensions: number): Promise<void> {
      if (!collections.has(name)) {
        collections.set(name, { dimensions, points: [] });
      }
    },

    async upsert(collection: string, points: VectorPoint[]): Promise<void> {
      const col = collections.get(collection);
      if (!col) throw new Error(`Collection ${collection} does not exist`);

      for (const point of points) {
        const idx = col.points.findIndex((p) => p.id === point.id);
        if (idx >= 0) {
          col.points[idx] = point;
        } else {
          col.points.push(point);
        }
      }
    },

    async search(
      collection: string,
      vector: number[],
      options: SearchOptions,
    ): Promise<SearchResult[]> {
      const col = collections.get(collection);
      if (!col) throw new Error(`Collection ${collection} does not exist`);

      const scored = col.points.map((p) => ({
        id: p.id,
        score: p.vector.reduce((sum, v, i) => sum + v * (vector[i] ?? 0), 0),
        payload: p.payload,
      }));

      scored.sort((a, b) => b.score - a.score);
      return scored.slice(0, options.limit);
    },
  };
}

describe("VectorStore interface contract", () => {
  it("ensureCollection creates a collection without error", async () => {
    const store = createMockVectorStore();
    await expect(store.ensureCollection("test", 3)).resolves.toBeUndefined();
  });

  it("ensureCollection is idempotent", async () => {
    const store = createMockVectorStore();
    await store.ensureCollection("test", 3);
    await expect(store.ensureCollection("test", 3)).resolves.toBeUndefined();
  });

  it("upsert stores points that can be searched", async () => {
    const store = createMockVectorStore();
    await store.ensureCollection("test", 3);

    const points: VectorPoint[] = [
      { id: "a", vector: [1, 0, 0], payload: { text: "alpha" } },
      { id: "b", vector: [0, 1, 0], payload: { text: "beta" } },
    ];
    await store.upsert("test", points);

    const results = await store.search("test", [1, 0, 0], { limit: 1 });
    expect(results).toHaveLength(1);
    expect(results[0].id).toBe("a");
    expect(results[0].payload.text).toBe("alpha");
  });

  it("upsert updates existing points", async () => {
    const store = createMockVectorStore();
    await store.ensureCollection("test", 3);

    await store.upsert("test", [
      { id: "a", vector: [1, 0, 0], payload: { text: "original" } },
    ]);
    await store.upsert("test", [
      { id: "a", vector: [1, 0, 0], payload: { text: "updated" } },
    ]);

    const results = await store.search("test", [1, 0, 0], { limit: 1 });
    expect(results[0].payload.text).toBe("updated");
  });

  it("search respects limit", async () => {
    const store = createMockVectorStore();
    await store.ensureCollection("test", 3);

    await store.upsert("test", [
      { id: "a", vector: [1, 0, 0], payload: { text: "a" } },
      { id: "b", vector: [0.9, 0.1, 0], payload: { text: "b" } },
      { id: "c", vector: [0.8, 0.2, 0], payload: { text: "c" } },
    ]);

    const results = await store.search("test", [1, 0, 0], { limit: 2 });
    expect(results).toHaveLength(2);
  });

  it("search results include score", async () => {
    const store = createMockVectorStore();
    await store.ensureCollection("test", 3);

    await store.upsert("test", [
      { id: "a", vector: [1, 0, 0], payload: { text: "a" } },
    ]);

    const results = await store.search("test", [1, 0, 0], { limit: 1 });
    expect(typeof results[0].score).toBe("number");
    expect(results[0].score).toBeGreaterThan(0);
  });

  it("search returns results ordered by score descending", async () => {
    const store = createMockVectorStore();
    await store.ensureCollection("test", 3);

    await store.upsert("test", [
      { id: "low", vector: [0.1, 0, 0], payload: { text: "low" } },
      { id: "high", vector: [1, 0, 0], payload: { text: "high" } },
      { id: "mid", vector: [0.5, 0, 0], payload: { text: "mid" } },
    ]);

    const results = await store.search("test", [1, 0, 0], { limit: 3 });
    expect(results[0].id).toBe("high");
    expect(results[1].id).toBe("mid");
    expect(results[2].id).toBe("low");
  });
});
```

**Step 3: Run the test to verify it passes**

```bash
cd api && npx vitest run src/interfaces/vector-store.test.ts
```

Expected: 7 tests pass.

**Step 4: Commit**

```bash
git add api/src/interfaces/vector-store.ts api/src/interfaces/vector-store.test.ts
git commit -m "feat: define VectorStore interface with contract tests"
```

---

### Task 6: Refactor Qdrant to implement VectorStore

**Files:**
- Modify: `api/src/qdrant.ts`
- Create: `api/src/qdrant.test.ts`

**Step 1: Write the failing test**

Create `api/src/qdrant.test.ts`:

```typescript
import { describe, it, expect, vi, afterEach } from "vitest";
import { createQdrantStore } from "./qdrant.js";
import type { VectorStore } from "./interfaces/vector-store.js";

// Mock the QdrantClient before importing
vi.mock("@qdrant/js-client-rest", () => {
  const collections = new Map<string, { points: Map<string, { id: string; vector: number[]; payload: Record<string, unknown> }> }>();

  return {
    QdrantClient: vi.fn().mockImplementation(() => ({
      getCollections: vi.fn().mockImplementation(async () => ({
        collections: Array.from(collections.keys()).map((name) => ({ name })),
      })),
      createCollection: vi.fn().mockImplementation(async (name: string) => {
        collections.set(name, { points: new Map() });
      }),
      upsert: vi.fn().mockImplementation(async (collection: string, opts: { points: Array<{ id: string; vector: number[]; payload: Record<string, unknown> }> }) => {
        const col = collections.get(collection);
        if (!col) throw new Error(`Collection ${collection} not found`);
        for (const p of opts.points) {
          col.points.set(String(p.id), p);
        }
      }),
      search: vi.fn().mockImplementation(async (collection: string, opts: { vector: number[]; limit: number }) => {
        const col = collections.get(collection);
        if (!col) return [];
        const results = Array.from(col.points.values())
          .map((p) => ({
            id: p.id,
            score: p.vector.reduce((sum, v, i) => sum + v * (opts.vector[i] ?? 0), 0),
            payload: p.payload,
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, opts.limit);
        return results;
      }),
    })),
  };
});

describe("QdrantStore", () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("createQdrantStore returns a VectorStore", () => {
    const store = createQdrantStore({ url: "http://localhost:6333" });

    expect(store).toBeDefined();
    expect(typeof store.ensureCollection).toBe("function");
    expect(typeof store.upsert).toBe("function");
    expect(typeof store.search).toBe("function");
  });

  it("ensureCollection calls QdrantClient", async () => {
    const store = createQdrantStore({ url: "http://localhost:6333" });
    await expect(store.ensureCollection("test", 768)).resolves.toBeUndefined();
  });

  it("upsert and search work through the VectorStore interface", async () => {
    const store: VectorStore = createQdrantStore({ url: "http://localhost:6333" });
    await store.ensureCollection("integration", 3);

    await store.upsert("integration", [
      { id: "doc1", vector: [1, 0, 0], payload: { text: "hello" } },
      { id: "doc2", vector: [0, 1, 0], payload: { text: "world" } },
    ]);

    const results = await store.search("integration", [1, 0, 0], { limit: 1 });
    expect(results).toHaveLength(1);
    expect(results[0].id).toBe("doc1");
    expect(results[0].payload.text).toBe("hello");
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/qdrant.test.ts
```

Expected: FAIL — `createQdrantStore` is not exported.

**Step 3: Implement — refactor qdrant.ts**

Replace `api/src/qdrant.ts` with:

```typescript
import { QdrantClient } from "@qdrant/js-client-rest";
import type {
  VectorStore,
  VectorPoint,
  SearchOptions,
  SearchResult,
} from "./interfaces/vector-store.js";

export interface QdrantStoreOptions {
  url?: string;
  distance?: string;
}

const DEFAULT_COLLECTION = process.env.QDRANT_COLLECTION || "docs";
const DEFAULT_DISTANCE = (process.env.DISTANCE || "Cosine") as "Cosine" | "Euclid" | "Dot";

/**
 * Create a VectorStore backed by Qdrant.
 */
export function createQdrantStore(
  options: QdrantStoreOptions = {},
): VectorStore {
  const url = options.url ?? process.env.QDRANT_URL ?? "http://qdrant:6333";
  const distance = (options.distance ?? DEFAULT_DISTANCE) as "Cosine" | "Euclid" | "Dot";
  const client = new QdrantClient({ url });

  return {
    async ensureCollection(name: string, dimensions: number): Promise<void> {
      const collections = await client.getCollections();
      const exists = collections.collections?.some((c) => c.name === name);
      if (exists) return;
      await client.createCollection(name, {
        vectors: { size: dimensions, distance },
      });
    },

    async upsert(collection: string, points: VectorPoint[]): Promise<void> {
      await client.upsert(collection, {
        wait: true,
        points: points.map((p) => ({
          id: p.id,
          vector: p.vector,
          payload: p.payload,
        })),
      });
    },

    async search(
      collection: string,
      vector: number[],
      options: SearchOptions,
    ): Promise<SearchResult[]> {
      const results = await client.search(collection, {
        vector,
        limit: options.limit,
        with_payload: true,
        filter: options.filter,
      });

      return (results ?? []).map((r) => ({
        id: r.id as string | number,
        score: r.score,
        payload: (r.payload ?? {}) as Record<string, unknown>,
      }));
    },
  };
}

/**
 * Legacy exports — maintained for backward compatibility during transition.
 * New code should use createQdrantStore().
 */
const QDRANT_URL = process.env.QDRANT_URL || "http://qdrant:6333";
export const qdrant = new QdrantClient({ url: QDRANT_URL });

export async function ensureCollection(name = DEFAULT_COLLECTION): Promise<void> {
  const vectorSize = Number(process.env.VECTOR_SIZE || "768");
  const collections = await qdrant.getCollections();
  const exists = collections.collections?.some((c) => c.name === name);
  if (exists) return;
  await qdrant.createCollection(name, {
    vectors: { size: vectorSize, distance: DEFAULT_DISTANCE },
  });
}

export function collectionName(name?: string): string {
  return name || DEFAULT_COLLECTION;
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/qdrant.test.ts
```

Expected: 3 tests pass.

**Step 5: Commit**

```bash
git add api/src/qdrant.ts api/src/qdrant.test.ts
git commit -m "refactor: extract QdrantStore implementing VectorStore interface"
```

---

### Task 7: Wire VectorStore into services and server

**Files:**
- Modify: `api/src/server.ts`
- Create: `api/src/providers/vector-factory.ts`
- Create: `api/src/providers/vector-factory.test.ts`

**Step 1: Write the failing test for the vector factory**

Create `api/src/providers/vector-factory.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";

// Mock Qdrant client before import
vi.mock("@qdrant/js-client-rest", () => ({
  QdrantClient: vi.fn().mockImplementation(() => ({
    getCollections: vi.fn().mockResolvedValue({ collections: [] }),
    createCollection: vi.fn().mockResolvedValue(undefined),
    upsert: vi.fn().mockResolvedValue(undefined),
    search: vi.fn().mockResolvedValue([]),
  })),
}));

import { createVectorStore } from "./vector-factory.js";

describe("createVectorStore", () => {
  const originalEnv = process.env;

  beforeEach(() => {
    process.env = { ...originalEnv };
  });

  afterEach(() => {
    process.env = originalEnv;
    vi.restoreAllMocks();
  });

  it("returns QdrantStore when VECTOR_BACKEND is 'qdrant'", () => {
    process.env.VECTOR_BACKEND = "qdrant";
    const store = createVectorStore();

    expect(store).toBeDefined();
    expect(typeof store.ensureCollection).toBe("function");
    expect(typeof store.upsert).toBe("function");
    expect(typeof store.search).toBe("function");
  });

  it("returns QdrantStore by default when VECTOR_BACKEND is not set", () => {
    delete process.env.VECTOR_BACKEND;
    const store = createVectorStore();

    expect(store).toBeDefined();
    expect(typeof store.ensureCollection).toBe("function");
  });

  it("throws for unknown backend", () => {
    process.env.VECTOR_BACKEND = "pinecone";
    expect(() => createVectorStore()).toThrow(
      /Unknown vector backend: "pinecone"/,
    );
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/providers/vector-factory.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement the vector factory**

Create `api/src/providers/vector-factory.ts`:

```typescript
import type { VectorStore } from "../interfaces/vector-store.js";
import { createQdrantStore } from "../qdrant.js";

/**
 * Create a VectorStore based on the VECTOR_BACKEND environment variable.
 * Supported values: "qdrant" (default).
 */
export function createVectorStore(): VectorStore {
  const backend = (process.env.VECTOR_BACKEND ?? "qdrant").toLowerCase();

  switch (backend) {
    case "qdrant":
      return createQdrantStore();
    default:
      throw new Error(
        `Unknown vector backend: "${backend}". Supported: qdrant`,
      );
  }
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/providers/vector-factory.test.ts
```

Expected: 3 tests pass.

**Step 5: Update server.ts to use VectorStore**

Replace `api/src/server.ts`:

```typescript
import Fastify from "fastify";
import { randomUUID } from "node:crypto";
import { createEmbeddingProvider } from "./providers/embedding-factory.js";
import { createVectorStore } from "./providers/vector-factory.js";
import { chunkText } from "./chunking.js";
import { registerAuth } from "./auth.js";
import type { VectorPoint } from "./interfaces/vector-store.js";

const embedder = createEmbeddingProvider();
const vectorStore = createVectorStore();

const app = Fastify({ logger: true });
registerAuth(app);

app.get("/healthz", async () => ({ ok: true }));

interface IngestItem {
  id?: string;
  text: string;
  source: string;
  metadata?: Record<string, unknown>;
}

interface IngestBody {
  collection?: string;
  items: IngestItem[];
}

interface QueryBody {
  collection?: string;
  query: string;
  topK?: number;
  filter?: Record<string, unknown>;
}

const DEFAULT_COLLECTION = process.env.QDRANT_COLLECTION || "docs";

function resolveCollection(name?: string): string {
  return name || DEFAULT_COLLECTION;
}

app.post("/ingest", async (req) => {
  const body = req.body as IngestBody;
  const col = resolveCollection(body.collection);
  await vectorStore.ensureCollection(col, embedder.dimensions);

  const points: VectorPoint[] = [];
  for (const item of body.items) {
    const baseId = item.id ?? randomUUID();
    const chunks = chunkText(item.text);
    const vectors = await embedder.embed(chunks);

    for (let i = 0; i < chunks.length; i++) {
      points.push({
        id: `${baseId}:${i}`,
        vector: vectors[i],
        payload: {
          text: chunks[i],
          source: item.source,
          chunkIndex: i,
          ...(item.metadata ?? {}),
        },
      });
    }
  }
  await vectorStore.upsert(col, points);
  return { ok: true, upserted: points.length };
});

app.post("/query", async (req) => {
  const body = req.body as QueryBody;
  const col = resolveCollection(body.collection);
  await vectorStore.ensureCollection(col, embedder.dimensions);

  const [vector] = await embedder.embed([body.query]);
  const topK = body.topK ?? 8;

  const results = await vectorStore.search(col, vector, {
    limit: topK,
    filter: body.filter,
  });

  return {
    ok: true,
    results: results.map((r) => ({
      id: r.id,
      score: r.score,
      source: r.payload.source,
      text: r.payload.text,
      payload: r.payload,
    })),
  };
});

const PORT = Number(process.env.PORT || "8080");
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

**Step 6: Run all tests**

```bash
cd api && npx vitest run
```

Expected: All tests pass.

**Step 7: Commit**

```bash
git add api/src/providers/vector-factory.ts api/src/providers/vector-factory.test.ts api/src/server.ts
git commit -m "feat: add vector store factory, wire VectorStore into server.ts"
```

---

### Task 8: Add rate limiting

**Files:**
- Create: `api/src/rate-limit.ts`
- Create: `api/src/rate-limit.test.ts`
- Modify: `api/src/server.ts`
- Modify: `api/package.json`

**Step 1: Install dependency**

```bash
cd api && npm install @fastify/rate-limit
```

**Step 2: Write the failing test**

Create `api/src/rate-limit.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
import Fastify, { type FastifyInstance } from "fastify";
import { registerRateLimit } from "./rate-limit.js";

describe("rate limiting", () => {
  let app: FastifyInstance;
  const originalEnv = process.env;

  beforeEach(async () => {
    process.env = { ...originalEnv };
    app = Fastify();
    app.get("/healthz", async () => ({ ok: true }));
    app.post("/ingest", async () => ({ ok: true }));
  });

  afterEach(async () => {
    process.env = originalEnv;
    await app.close();
  });

  it("returns 429 after exceeding rate limit", async () => {
    process.env.RATE_LIMIT_MAX = "3";
    process.env.RATE_LIMIT_WINDOW = "60000";
    await registerRateLimit(app);
    await app.ready();

    // Make requests up to the limit
    for (let i = 0; i < 3; i++) {
      const res = await app.inject({
        method: "POST",
        url: "/ingest",
        payload: {},
      });
      expect(res.statusCode).toBe(200);
    }

    // Next request should be rate limited
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {},
    });
    expect(res.statusCode).toBe(429);
    const body = JSON.parse(res.payload);
    expect(body.error).toMatch(/rate limit/i);
  });

  it("does not rate limit /healthz", async () => {
    process.env.RATE_LIMIT_MAX = "1";
    process.env.RATE_LIMIT_WINDOW = "60000";
    await registerRateLimit(app);
    await app.ready();

    // Use up the rate limit
    await app.inject({ method: "POST", url: "/ingest", payload: {} });

    // /healthz should still work
    const res = await app.inject({ method: "GET", url: "/healthz" });
    expect(res.statusCode).toBe(200);
  });

  it("uses default values when env vars not set", async () => {
    delete process.env.RATE_LIMIT_MAX;
    delete process.env.RATE_LIMIT_WINDOW;
    await registerRateLimit(app);
    await app.ready();

    // Should accept at least one request (default is 100/min)
    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {},
    });
    expect(res.statusCode).toBe(200);
  });

  it("includes rate limit headers in response", async () => {
    process.env.RATE_LIMIT_MAX = "10";
    process.env.RATE_LIMIT_WINDOW = "60000";
    await registerRateLimit(app);
    await app.ready();

    const res = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {},
    });

    expect(res.headers["x-ratelimit-limit"]).toBeDefined();
    expect(res.headers["x-ratelimit-remaining"]).toBeDefined();
  });
});
```

**Step 3: Run the test to verify failure**

```bash
cd api && npx vitest run src/rate-limit.test.ts
```

Expected: FAIL — module not found.

**Step 4: Implement**

Create `api/src/rate-limit.ts`:

```typescript
import type { FastifyInstance } from "fastify";
import rateLimit from "@fastify/rate-limit";

/**
 * Register request rate limiting as a Fastify plugin.
 *
 * Configuration via environment variables:
 *   RATE_LIMIT_MAX    — max requests per window (default: 100)
 *   RATE_LIMIT_WINDOW — window duration in ms (default: 60000 = 1 minute)
 *
 * /healthz is always exempt from rate limiting.
 */
export async function registerRateLimit(app: FastifyInstance): Promise<void> {
  const max = Number(process.env.RATE_LIMIT_MAX || "100");
  const timeWindow = Number(process.env.RATE_LIMIT_WINDOW || "60000");

  await app.register(rateLimit, {
    max,
    timeWindow,
    allowList: (req) => {
      return req.url?.startsWith("/healthz") ?? false;
    },
    errorResponseBuilder: (_req, context) => ({
      error: `Rate limit exceeded. Max ${context.max} requests per ${context.after}. Try again later.`,
    }),
  });
}
```

**Step 5: Run tests to verify they pass**

```bash
cd api && npx vitest run src/rate-limit.test.ts
```

Expected: 4 tests pass.

**Step 6: Wire into server.ts**

Add after `registerAuth(app);` in `api/src/server.ts`:

```typescript
import { registerRateLimit } from "./rate-limit.js";

// ... after registerAuth(app);
await registerRateLimit(app);
```

The full updated server.ts top section becomes:

```typescript
import Fastify from "fastify";
import { randomUUID } from "node:crypto";
import { createEmbeddingProvider } from "./providers/embedding-factory.js";
import { createVectorStore } from "./providers/vector-factory.js";
import { chunkText } from "./chunking.js";
import { registerAuth } from "./auth.js";
import { registerRateLimit } from "./rate-limit.js";
import type { VectorPoint } from "./interfaces/vector-store.js";

const embedder = createEmbeddingProvider();
const vectorStore = createVectorStore();

const app = Fastify({ logger: true });
registerAuth(app);
await registerRateLimit(app);
```

**Step 7: Run all tests**

```bash
cd api && npx vitest run
```

Expected: All tests pass.

**Step 8: Commit**

```bash
git add api/src/rate-limit.ts api/src/rate-limit.test.ts api/src/server.ts api/package.json api/package-lock.json
git commit -m "feat: add rate limiting with configurable max/window, /healthz exempt"
```

---

### Task 9: Structured logging with correlation IDs

**Files:**
- Create: `api/src/logger.ts`
- Create: `api/src/logger.test.ts`
- Modify: `api/src/server.ts`

**Step 1: Write the failing test**

Create `api/src/logger.test.ts`:

```typescript
import { describe, it, expect, afterEach } from "vitest";
import Fastify, { type FastifyInstance } from "fastify";
import { createLoggerConfig } from "./logger.js";

describe("structured logging", () => {
  let app: FastifyInstance;
  const logs: string[] = [];

  afterEach(async () => {
    if (app) await app.close();
    logs.length = 0;
  });

  it("generates a request ID for every request", async () => {
    const config = createLoggerConfig();
    app = Fastify({
      logger: config,
      // Capture log output to a writable stream
      ...(config.stream ? {} : {}),
    });
    app.get("/test", async (req) => ({ requestId: req.id }));
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/test" });
    const body = JSON.parse(res.payload);

    expect(body.requestId).toBeDefined();
    expect(typeof body.requestId).toBe("string");
    expect(body.requestId.length).toBeGreaterThan(0);
  });

  it("includes X-Request-Id in response headers", async () => {
    const config = createLoggerConfig();
    app = Fastify({ logger: config });
    app.addHook("onSend", async (req, reply) => {
      void reply.header("x-request-id", req.id);
    });
    app.get("/test", async () => ({ ok: true }));
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/test" });

    expect(res.headers["x-request-id"]).toBeDefined();
    expect(typeof res.headers["x-request-id"]).toBe("string");
  });

  it("uses X-Request-Id from incoming request when provided", async () => {
    const config = createLoggerConfig();
    app = Fastify({
      logger: config,
      genReqId: config.genReqId,
    });
    app.addHook("onSend", async (req, reply) => {
      void reply.header("x-request-id", req.id);
    });
    app.get("/test", async (req) => ({ requestId: req.id }));
    await app.ready();

    const res = await app.inject({
      method: "GET",
      url: "/test",
      headers: { "x-request-id": "custom-correlation-id-123" },
    });
    const body = JSON.parse(res.payload);

    expect(body.requestId).toBe("custom-correlation-id-123");
    expect(res.headers["x-request-id"]).toBe("custom-correlation-id-123");
  });

  it("logger config includes serializers for request and response", () => {
    const config = createLoggerConfig();

    expect(config.serializers).toBeDefined();
    expect(config.serializers?.req).toBeDefined();
    expect(config.serializers?.res).toBeDefined();
  });

  it("request serializer includes method, url, and requestId", () => {
    const config = createLoggerConfig();
    const serialized = config.serializers?.req?.({
      method: "POST",
      url: "/ingest",
      id: "req-123",
      headers: {},
    } as never) as Record<string, unknown>;

    expect(serialized?.method).toBe("POST");
    expect(serialized?.url).toBe("/ingest");
    expect(serialized?.requestId).toBe("req-123");
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/logger.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement**

Create `api/src/logger.ts`:

```typescript
import { randomUUID } from "node:crypto";
import type { FastifyRequest, FastifyReply } from "fastify";

interface LoggerConfig {
  level: string;
  genReqId: (req: FastifyRequest) => string;
  serializers: {
    req: (req: FastifyRequest) => Record<string, unknown>;
    res: (res: FastifyReply) => Record<string, unknown>;
  };
}

/**
 * Create a structured pino logger configuration for Fastify.
 *
 * Features:
 * - Generates UUID request IDs (or uses incoming X-Request-Id header)
 * - Structured serializers for request/response with method, url, statusCode
 * - Configurable log level via LOG_LEVEL env var (default: "info")
 */
export function createLoggerConfig(): LoggerConfig {
  const level = process.env.LOG_LEVEL ?? "info";

  return {
    level,

    genReqId(req: FastifyRequest): string {
      const incoming = req.headers["x-request-id"];
      if (typeof incoming === "string" && incoming.length > 0) {
        return incoming;
      }
      return randomUUID();
    },

    serializers: {
      req(req: FastifyRequest): Record<string, unknown> {
        return {
          method: req.method,
          url: req.url,
          requestId: req.id,
        };
      },
      res(res: FastifyReply): Record<string, unknown> {
        return {
          statusCode: res.statusCode,
        };
      },
    },
  };
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/logger.test.ts
```

Expected: 5 tests pass.

**Step 5: Wire into server.ts**

Update the Fastify instantiation in `api/src/server.ts`:

```typescript
import Fastify from "fastify";
import { randomUUID } from "node:crypto";
import { createEmbeddingProvider } from "./providers/embedding-factory.js";
import { createVectorStore } from "./providers/vector-factory.js";
import { chunkText } from "./chunking.js";
import { registerAuth } from "./auth.js";
import { registerRateLimit } from "./rate-limit.js";
import { createLoggerConfig } from "./logger.js";
import type { VectorPoint } from "./interfaces/vector-store.js";

const embedder = createEmbeddingProvider();
const vectorStore = createVectorStore();

const loggerConfig = createLoggerConfig();
const app = Fastify({
  logger: loggerConfig,
  genReqId: loggerConfig.genReqId,
});

// Add X-Request-Id to all responses for correlation
app.addHook("onSend", async (req, reply) => {
  void reply.header("x-request-id", req.id);
});

registerAuth(app);
await registerRateLimit(app);
```

The rest of server.ts remains the same.

**Step 6: Run all tests**

```bash
cd api && npx vitest run
```

Expected: All tests pass.

**Step 7: Commit**

```bash
git add api/src/logger.ts api/src/logger.test.ts api/src/server.ts
git commit -m "feat: add structured logging with correlation IDs (X-Request-Id)"
```

---

### Task 10: API versioning

**Files:**
- Create: `api/src/versioning.ts`
- Create: `api/src/versioning.test.ts`
- Modify: `api/src/server.ts`

**Step 1: Write the failing test**

Create `api/src/versioning.test.ts`:

```typescript
import { describe, it, expect, afterEach } from "vitest";
import Fastify, { type FastifyInstance } from "fastify";
import { registerVersionedRoutes } from "./versioning.js";

describe("API versioning", () => {
  let app: FastifyInstance;

  afterEach(async () => {
    if (app) await app.close();
  });

  it("versioned route /v1/test returns X-API-Version header", async () => {
    app = Fastify();
    const handler = async () => ({ ok: true });
    registerVersionedRoutes(app, [
      { method: "GET", path: "/test", handler },
    ]);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/v1/test" });

    expect(res.statusCode).toBe(200);
    expect(res.headers["x-api-version"]).toBe("v1");
  });

  it("unversioned route /test returns deprecation header", async () => {
    app = Fastify();
    const handler = async () => ({ ok: true });
    registerVersionedRoutes(app, [
      { method: "GET", path: "/test", handler },
    ]);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/test" });

    expect(res.statusCode).toBe(200);
    expect(res.headers["deprecation"]).toBe("true");
    expect(res.headers["x-api-version"]).toBe("v1");
    expect(res.headers["sunset"]).toBeDefined();
  });

  it("both /v1/ingest and /ingest return same response", async () => {
    app = Fastify();
    const handler = async () => ({ ok: true, route: "ingest" });
    registerVersionedRoutes(app, [
      { method: "POST", path: "/ingest", handler },
    ]);
    await app.ready();

    const versioned = await app.inject({
      method: "POST",
      url: "/v1/ingest",
      payload: {},
    });
    const unversioned = await app.inject({
      method: "POST",
      url: "/ingest",
      payload: {},
    });

    expect(JSON.parse(versioned.payload)).toEqual({
      ok: true,
      route: "ingest",
    });
    expect(JSON.parse(unversioned.payload)).toEqual({
      ok: true,
      route: "ingest",
    });
  });

  it("both /v1/query and /query return same response", async () => {
    app = Fastify();
    const handler = async () => ({ ok: true, route: "query" });
    registerVersionedRoutes(app, [
      { method: "POST", path: "/query", handler },
    ]);
    await app.ready();

    const versioned = await app.inject({
      method: "POST",
      url: "/v1/query",
      payload: {},
    });
    const unversioned = await app.inject({
      method: "POST",
      url: "/query",
      payload: {},
    });

    expect(JSON.parse(versioned.payload)).toEqual({
      ok: true,
      route: "query",
    });
    expect(JSON.parse(unversioned.payload)).toEqual({
      ok: true,
      route: "query",
    });
  });

  it("registers multiple routes at once", async () => {
    app = Fastify();
    registerVersionedRoutes(app, [
      { method: "POST", path: "/ingest", handler: async () => ({ op: "ingest" }) },
      { method: "POST", path: "/query", handler: async () => ({ op: "query" }) },
    ]);
    await app.ready();

    const r1 = await app.inject({ method: "POST", url: "/v1/ingest", payload: {} });
    const r2 = await app.inject({ method: "POST", url: "/v1/query", payload: {} });

    expect(JSON.parse(r1.payload).op).toBe("ingest");
    expect(JSON.parse(r2.payload).op).toBe("query");
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/versioning.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement**

Create `api/src/versioning.ts`:

```typescript
import type {
  FastifyInstance,
  FastifyRequest,
  FastifyReply,
  RouteHandlerMethod,
  HTTPMethods,
} from "fastify";

export interface RouteDefinition {
  method: HTTPMethods;
  path: string;
  handler: RouteHandlerMethod;
  schema?: Record<string, unknown>;
}

/**
 * Register routes under both /v1/<path> (canonical) and /<path> (deprecated alias).
 *
 * - Versioned routes (/v1/...) include X-API-Version: v1 header.
 * - Unversioned routes (/...) include X-API-Version, Deprecation, and Sunset headers.
 *
 * Sunset date is set to 6 months from now to signal planned removal.
 */
export function registerVersionedRoutes(
  app: FastifyInstance,
  routes: RouteDefinition[],
): void {
  const sunsetDate = new Date();
  sunsetDate.setMonth(sunsetDate.getMonth() + 6);
  const sunsetStr = sunsetDate.toUTCString();

  for (const route of routes) {
    // Versioned route: /v1/<path>
    app.route({
      method: route.method,
      url: `/v1${route.path}`,
      schema: route.schema,
      handler: async (req: FastifyRequest, reply: FastifyReply) => {
        void reply.header("x-api-version", "v1");
        return route.handler.call(app, req, reply);
      },
    });

    // Unversioned route: /<path> (deprecated alias)
    app.route({
      method: route.method,
      url: route.path,
      schema: route.schema,
      handler: async (req: FastifyRequest, reply: FastifyReply) => {
        void reply.header("x-api-version", "v1");
        void reply.header("deprecation", "true");
        void reply.header("sunset", sunsetStr);
        return route.handler.call(app, req, reply);
      },
    });
  }
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/versioning.test.ts
```

Expected: 5 tests pass.

**Step 5: Wire into server.ts**

Update `api/src/server.ts` to use versioned routes:

```typescript
import Fastify from "fastify";
import { randomUUID } from "node:crypto";
import { createEmbeddingProvider } from "./providers/embedding-factory.js";
import { createVectorStore } from "./providers/vector-factory.js";
import { chunkText } from "./chunking.js";
import { registerAuth } from "./auth.js";
import { registerRateLimit } from "./rate-limit.js";
import { createLoggerConfig } from "./logger.js";
import { registerVersionedRoutes } from "./versioning.js";
import type { VectorPoint } from "./interfaces/vector-store.js";

const embedder = createEmbeddingProvider();
const vectorStore = createVectorStore();

const loggerConfig = createLoggerConfig();
const app = Fastify({
  logger: loggerConfig,
  genReqId: loggerConfig.genReqId,
});

// Add X-Request-Id to all responses for correlation
app.addHook("onSend", async (req, reply) => {
  void reply.header("x-request-id", req.id);
});

registerAuth(app);
await registerRateLimit(app);

// Healthz — always unversioned, unauthenticated
app.get("/healthz", async () => ({ ok: true }));

const DEFAULT_COLLECTION = process.env.QDRANT_COLLECTION || "docs";

function resolveCollection(name?: string): string {
  return name || DEFAULT_COLLECTION;
}

interface IngestItem {
  id?: string;
  text: string;
  source: string;
  metadata?: Record<string, unknown>;
}

interface IngestBody {
  collection?: string;
  items: IngestItem[];
}

interface QueryBody {
  collection?: string;
  query: string;
  topK?: number;
  filter?: Record<string, unknown>;
}

// Register /v1/ingest + /ingest and /v1/query + /query
registerVersionedRoutes(app, [
  {
    method: "POST",
    path: "/ingest",
    handler: async (req) => {
      const body = req.body as IngestBody;
      const col = resolveCollection(body.collection);
      await vectorStore.ensureCollection(col, embedder.dimensions);

      const points: VectorPoint[] = [];
      for (const item of body.items) {
        const baseId = item.id ?? randomUUID();
        const chunks = chunkText(item.text);
        const vectors = await embedder.embed(chunks);

        for (let i = 0; i < chunks.length; i++) {
          points.push({
            id: `${baseId}:${i}`,
            vector: vectors[i],
            payload: {
              text: chunks[i],
              source: item.source,
              chunkIndex: i,
              ...(item.metadata ?? {}),
            },
          });
        }
      }
      await vectorStore.upsert(col, points);
      return { ok: true, upserted: points.length };
    },
  },
  {
    method: "POST",
    path: "/query",
    handler: async (req) => {
      const body = req.body as QueryBody;
      const col = resolveCollection(body.collection);
      await vectorStore.ensureCollection(col, embedder.dimensions);

      const [vector] = await embedder.embed([body.query]);
      const topK = body.topK ?? 8;

      const results = await vectorStore.search(col, vector, {
        limit: topK,
        filter: body.filter,
      });

      return {
        ok: true,
        results: results.map((r) => ({
          id: r.id,
          score: r.score,
          source: r.payload.source,
          text: r.payload.text,
          payload: r.payload,
        })),
      };
    },
  },
]);

const PORT = Number(process.env.PORT || "8080");
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

**Step 6: Run all tests**

```bash
cd api && npx vitest run
```

Expected: All tests pass.

**Step 7: Commit**

```bash
git add api/src/versioning.ts api/src/versioning.test.ts api/src/server.ts
git commit -m "feat: add API versioning with /v1/ prefix and deprecation headers"
```

---

### Task 11: Enhanced health checks

**Files:**
- Create: `api/src/health.ts`
- Create: `api/src/health.test.ts`
- Modify: `api/src/server.ts`

**Step 1: Write the failing test**

Create `api/src/health.test.ts`:

```typescript
import { describe, it, expect, vi, afterEach } from "vitest";
import Fastify, { type FastifyInstance } from "fastify";
import { createHealthHandler } from "./health.js";
import type { VectorStore } from "./interfaces/vector-store.js";
import type { EmbeddingProvider } from "./interfaces/embedding.js";

function createMockVectorStore(healthy: boolean): VectorStore {
  return {
    async ensureCollection(): Promise<void> {
      if (!healthy) throw new Error("connection refused");
    },
    async upsert(): Promise<void> {},
    async search(): Promise<[]> {
      return [];
    },
  };
}

function createMockEmbedder(healthy: boolean): EmbeddingProvider {
  return {
    name: "mock",
    dimensions: 768,
    async embed(texts: string[]): Promise<number[][]> {
      if (!healthy) throw new Error("model not found");
      return texts.map(() => []);
    },
  };
}

describe("enhanced health check", () => {
  let app: FastifyInstance;

  afterEach(async () => {
    if (app) await app.close();
  });

  it("returns ok:true when all dependencies are healthy", async () => {
    app = Fastify();
    const handler = createHealthHandler({
      vectorStore: createMockVectorStore(true),
      embedder: createMockEmbedder(true),
      version: "1.0.0",
    });
    app.get("/healthz", handler);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/healthz" });
    const body = JSON.parse(res.payload);

    expect(res.statusCode).toBe(200);
    expect(body.ok).toBe(true);
    expect(body.version).toBe("1.0.0");
    expect(body.qdrant).toBe("connected");
    expect(body.embedder).toBe("connected");
  });

  it("returns ok:false when vector store is down", async () => {
    app = Fastify();
    const handler = createHealthHandler({
      vectorStore: createMockVectorStore(false),
      embedder: createMockEmbedder(true),
      version: "1.0.0",
    });
    app.get("/healthz", handler);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/healthz" });
    const body = JSON.parse(res.payload);

    expect(res.statusCode).toBe(503);
    expect(body.ok).toBe(false);
    expect(body.qdrant).toMatch(/error: connection refused/);
    expect(body.embedder).toBe("connected");
  });

  it("returns ok:false when embedder is down", async () => {
    app = Fastify();
    const handler = createHealthHandler({
      vectorStore: createMockVectorStore(true),
      embedder: createMockEmbedder(false),
      version: "1.0.0",
    });
    app.get("/healthz", handler);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/healthz" });
    const body = JSON.parse(res.payload);

    expect(res.statusCode).toBe(503);
    expect(body.ok).toBe(false);
    expect(body.qdrant).toBe("connected");
    expect(body.embedder).toMatch(/error: model not found/);
  });

  it("returns ok:false when both are down", async () => {
    app = Fastify();
    const handler = createHealthHandler({
      vectorStore: createMockVectorStore(false),
      embedder: createMockEmbedder(false),
      version: "1.0.0",
    });
    app.get("/healthz", handler);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/healthz" });
    const body = JSON.parse(res.payload);

    expect(res.statusCode).toBe(503);
    expect(body.ok).toBe(false);
    expect(body.qdrant).toMatch(/error:/);
    expect(body.embedder).toMatch(/error:/);
  });

  it("includes embedder name in response", async () => {
    app = Fastify();
    const handler = createHealthHandler({
      vectorStore: createMockVectorStore(true),
      embedder: createMockEmbedder(true),
      version: "1.0.0",
    });
    app.get("/healthz", handler);
    await app.ready();

    const res = await app.inject({ method: "GET", url: "/healthz" });
    const body = JSON.parse(res.payload);

    expect(body.embedderName).toBe("mock");
  });
});
```

**Step 2: Run the test to verify failure**

```bash
cd api && npx vitest run src/health.test.ts
```

Expected: FAIL — module not found.

**Step 3: Implement**

Create `api/src/health.ts`:

```typescript
import type { FastifyRequest, FastifyReply, RouteHandlerMethod } from "fastify";
import type { VectorStore } from "./interfaces/vector-store.js";
import type { EmbeddingProvider } from "./interfaces/embedding.js";

export interface HealthDependencies {
  vectorStore: VectorStore;
  embedder: EmbeddingProvider;
  version: string;
}

interface HealthResponse {
  ok: boolean;
  version: string;
  qdrant: string;
  embedder: string;
  embedderName: string;
}

/**
 * Create a health check handler that probes dependencies.
 *
 * Checks:
 * - Vector store: calls ensureCollection with a probe collection name
 * - Embedder: calls embed with a trivial input
 *
 * Returns 200 if all dependencies are healthy, 503 otherwise.
 */
export function createHealthHandler(
  deps: HealthDependencies,
): RouteHandlerMethod {
  return async (_req: FastifyRequest, reply: FastifyReply) => {
    const response: HealthResponse = {
      ok: true,
      version: deps.version,
      qdrant: "connected",
      embedder: "connected",
      embedderName: deps.embedder.name,
    };

    // Probe vector store
    try {
      await deps.vectorStore.ensureCollection(
        "__healthcheck",
        deps.embedder.dimensions,
      );
    } catch (err: unknown) {
      response.ok = false;
      const message = err instanceof Error ? err.message : String(err);
      response.qdrant = `error: ${message}`;
    }

    // Probe embedder
    try {
      await deps.embedder.embed(["health check"]);
    } catch (err: unknown) {
      response.ok = false;
      const message = err instanceof Error ? err.message : String(err);
      response.embedder = `error: ${message}`;
    }

    const statusCode = response.ok ? 200 : 503;
    return reply.code(statusCode).send(response);
  };
}
```

**Step 4: Run tests to verify they pass**

```bash
cd api && npx vitest run src/health.test.ts
```

Expected: 5 tests pass.

**Step 5: Wire into server.ts**

Update the healthz route in `api/src/server.ts`:

```typescript
import { createHealthHandler } from "./health.js";

// Replace:
//   app.get("/healthz", async () => ({ ok: true }));
// With:
app.get("/healthz", createHealthHandler({
  vectorStore,
  embedder,
  version: "1.0.0",
}));
```

**Step 6: Run all tests**

```bash
cd api && npx vitest run
```

Expected: All tests pass.

**Step 7: Commit**

```bash
git add api/src/health.ts api/src/health.test.ts api/src/server.ts
git commit -m "feat: enhanced health checks probing vector store and embedder connectivity"
```

---

### Task 12: Update documentation

**Files:**
- Modify: `api/AGENTS.md`
- Modify: `docs/09-api-reference.md`
- Modify: `docs/00-vision.md`

**Step 1: Update api/AGENTS.md with new module structure**

Replace the Module Structure section in `api/AGENTS.md`:

```markdown
# AGENTS.md — api/

> Inherits all principles from the root [AGENTS.md](../AGENTS.md). This file adds API-specific rules.

## Module Structure

```
src/
  server.ts                    → Fastify app setup, route registration, server start
  auth.ts                      → Authentication hook (bearer token)
  chunking.ts                  → Text chunking logic
  health.ts                    → Enhanced health check handler
  logger.ts                    → Structured pino logger configuration
  rate-limit.ts                → Rate limiting plugin
  versioning.ts                → API versioning (/v1/ prefix + deprecation)
  ollama.ts                    → Ollama embedding provider
  qdrant.ts                    → Qdrant vector store adapter
  interfaces/
    embedding.ts               → EmbeddingProvider interface
    vector-store.ts            → VectorStore interface
  providers/
    embedding-factory.ts       → EmbeddingProvider factory (reads EMBED_PROVIDER)
    vector-factory.ts          → VectorStore factory (reads VECTOR_BACKEND)
    openai-embeddings.ts       → OpenAI embedding provider
  services/
    ingest.ts                  → Ingest service (if extracted from server.ts)
    query.ts                   → Query service (if extracted from server.ts)
```

## Rules

### Route Handlers Stay Thin

Route handlers in `server.ts` must only: parse input, call service functions, return output. No business logic in handlers. If a handler grows beyond ~15 lines, extract the logic into a service module.

### Fastify Plugins for Cross-Cutting Concerns

Authentication, logging, rate limiting, and other cross-cutting concerns must be registered as Fastify hooks or plugins — not inlined into route handlers. See `auth.ts`, `rate-limit.ts`, `logger.ts` for the pattern.

### Adapter Interfaces

All external dependencies (embedding providers, vector backends) must be accessed through interfaces defined in `src/interfaces/`. New providers are added by creating new modules that implement the interface, then registering them in the corresponding factory.

### Input Validation

Every route must validate its input. Use Fastify's built-in JSON Schema validation on route definitions. Do not validate inside handler functions.

### Single Responsibility Per Module

- `chunking.ts` — only text chunking. No embedding, no HTTP, no Qdrant.
- `ollama.ts` — only embedding via Ollama. No chunking, no Qdrant.
- `qdrant.ts` — only Qdrant vector store adapter. No embedding, no chunking.
- `auth.ts` — only authentication. No business logic.
- `rate-limit.ts` — only rate limiting.
- `logger.ts` — only logger configuration.
- `health.ts` — only health check logic.
- `versioning.ts` — only API versioning.

If a new concern appears, create a new module.

### Health Endpoint

`/healthz` must always be unauthenticated and exempt from rate limiting. It probes Qdrant and the embedder for connectivity and returns detailed status.

### Error Responses

Return structured JSON errors: `{ error: "<message>" }`. Use appropriate HTTP status codes. Never expose stack traces in production responses.

### Environment Variables

All configuration is via environment variables. Document every env var in this file:

| Variable | Default | Description |
|----------|---------|-------------|
| `QDRANT_URL` | `http://qdrant:6333` | Qdrant server URL |
| `OLLAMA_URL` | `http://ollama:11434` | Ollama server URL |
| `QDRANT_COLLECTION` | `docs` | Default collection name |
| `VECTOR_SIZE` | `768` | Embedding vector dimensions |
| `DISTANCE` | `Cosine` | Qdrant distance metric |
| `EMBED_MODEL` | `nomic-embed-text` | Ollama embedding model |
| `PORT` | `8080` | API listen port |
| `RAG_API_TOKEN` | _(empty)_ | Bearer token for auth (empty = auth disabled) |
| `EMBED_PROVIDER` | `ollama` | Embedding provider: `ollama` or `openai` |
| `OPENAI_API_KEY` | _(empty)_ | OpenAI API key (required when EMBED_PROVIDER=openai) |
| `VECTOR_BACKEND` | `qdrant` | Vector store backend: `qdrant` |
| `RATE_LIMIT_MAX` | `100` | Max requests per rate limit window |
| `RATE_LIMIT_WINDOW` | `60000` | Rate limit window in milliseconds |
| `LOG_LEVEL` | `info` | Log level (trace, debug, info, warn, error, fatal) |
```

**Step 2: Update docs/09-api-reference.md**

Replace the entire contents of `docs/09-api-reference.md`:

```markdown
# API Reference

HTTP API for the rag-stack RAG service.

**Base URL:** `http://localhost:8080` (local) or your Ingress hostname (remote)

**API Version:** v1. All endpoints are available under `/v1/` prefix (recommended) or without prefix (deprecated, will be removed in a future release).

## Authentication

When `RAG_API_TOKEN` is set on the server, all endpoints except `/healthz` require a bearer token:

```
Authorization: Bearer <token>
```

## Rate Limiting

All endpoints except `/healthz` are rate-limited. Default: 100 requests per minute per IP.

Configuration:
- `RATE_LIMIT_MAX` — max requests per window (default: `100`)
- `RATE_LIMIT_WINDOW` — window in milliseconds (default: `60000`)

When rate limited, the API returns:
```json
{
  "error": "Rate limit exceeded. Max 100 requests per 1 minute. Try again later."
}
```

Response headers include `X-RateLimit-Limit`, `X-RateLimit-Remaining`, and `X-RateLimit-Reset`.

## Common Response Headers

| Header | Description |
|--------|-------------|
| `X-Request-Id` | Correlation ID for tracing (UUID or forwarded from request) |
| `X-API-Version` | API version (`v1`) |
| `Deprecation` | Present on unversioned routes (`true`) |
| `Sunset` | Planned removal date for unversioned routes |

## Endpoints

### GET /healthz

Health check with dependency probing. Always unauthenticated, exempt from rate limiting.

**Response (all healthy, 200):**
```json
{
  "ok": true,
  "version": "1.0.0",
  "qdrant": "connected",
  "embedder": "connected",
  "embedderName": "ollama"
}
```

**Response (dependency down, 503):**
```json
{
  "ok": false,
  "version": "1.0.0",
  "qdrant": "error: connection refused",
  "embedder": "connected",
  "embedderName": "ollama"
}
```

---

### POST /v1/ingest

Chunk, embed, and store text items in a vector collection.

**Also available at:** `POST /ingest` (deprecated — use `/v1/ingest`)

**Request:**
```json
{
  "collection": "docs",
  "items": [
    {
      "id": "my-repo:src/auth.ts",
      "text": "import { FastifyInstance } from 'fastify';\n...",
      "source": "https://github.com/org/repo#src/auth.ts",
      "metadata": {
        "repoId": "my-repo",
        "path": "src/auth.ts",
        "lang": "ts",
        "bytes": 1234
      }
    }
  ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `collection` | string | No | Collection name (default: `docs`) |
| `items` | array | Yes | Items to ingest |
| `items[].id` | string | No | Base ID for chunks (auto-generated UUID if omitted) |
| `items[].text` | string | Yes | Full text content to chunk and embed |
| `items[].source` | string | Yes | Source identifier (URL, path, etc.) |
| `items[].metadata` | object | No | Additional metadata stored with each chunk |

**Response:**
```json
{
  "ok": true,
  "upserted": 12
}
```

---

### POST /v1/query

Embed a query and search for similar chunks.

**Also available at:** `POST /query` (deprecated — use `/v1/query`)

**Request:**
```json
{
  "collection": "docs",
  "query": "authentication flow",
  "topK": 5,
  "filter": {
    "must": [
      { "key": "repoId", "match": { "value": "my-repo" } }
    ]
  }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `collection` | string | No | Collection name (default: `docs`) |
| `query` | string | Yes | Search query text |
| `topK` | number | No | Number of results (default: `8`) |
| `filter` | object | No | Vector store filter object |

**Response:**
```json
{
  "ok": true,
  "results": [
    {
      "id": "my-repo:src/auth.ts:0",
      "score": 0.87,
      "source": "https://github.com/org/repo#src/auth.ts",
      "text": "import { FastifyInstance } from 'fastify';\n...",
      "payload": {
        "text": "...",
        "source": "...",
        "chunkIndex": 0,
        "repoId": "my-repo",
        "lang": "ts"
      }
    }
  ]
}
```

**Filter Examples:**

Filter by repository:
```json
{ "must": [{ "key": "repoId", "match": { "value": "my-repo" } }] }
```

Filter by language:
```json
{ "must": [{ "key": "lang", "match": { "value": "ts" } }] }
```

Combine filters:
```json
{
  "must": [
    { "key": "repoId", "match": { "value": "my-repo" } },
    { "key": "lang", "match": { "value": "ts" } },
    { "key": "path", "match": { "text": "src/" } }
  ]
}
```

## Embedding Providers

The API supports swappable embedding providers via the `EMBED_PROVIDER` environment variable.

| Provider | `EMBED_PROVIDER` | Dimensions | Required Env Vars |
|----------|------------------|------------|-------------------|
| Ollama (default) | `ollama` | 768 | `OLLAMA_URL` |
| OpenAI | `openai` | 1536 | `OPENAI_API_KEY` |

## Vector Backends

The API supports swappable vector storage backends via the `VECTOR_BACKEND` environment variable.

| Backend | `VECTOR_BACKEND` | Required Env Vars |
|---------|------------------|-------------------|
| Qdrant (default) | `qdrant` | `QDRANT_URL` |
```

**Step 3: Update docs/00-vision.md**

In `docs/00-vision.md`, update the v1.0 roadmap section to mark completed items:

Find the v1.0 section and update with checkmarks:

```markdown
### v1.0 — Production Ready + Relationship Tracking

Hardening the vector layer and adding explicit relationship tracking:

**Production hardening:**
- [x] **Testing:** Unit tests for core logic, integration tests for API routes
- [x] **Input validation:** JSON Schema on all API routes
- [x] **Multiple embedding providers:** Adapter pattern — swap Ollama for OpenAI, Cohere, or local alternatives
- [x] **Pluggable vector backends:** Qdrant today, Pinecone/Weaviate/pgvector via adapters
- [x] **Rate limiting and request throttling**
- [x] **Structured logging and health checks** (beyond `/healthz`)
- [x] **API versioning** (`/v1/ingest`, `/v1/query`)
```

**Step 4: Verify**

```bash
head -5 api/AGENTS.md
head -5 docs/09-api-reference.md
head -5 docs/00-vision.md
```

Expected: All files render correctly.

**Step 5: Commit**

```bash
git add api/AGENTS.md docs/09-api-reference.md docs/00-vision.md
git commit -m "docs: update AGENTS.md, API reference, and vision for v1.0 production hardening"
```

---

## Summary

| Task | Files | Type | What |
|------|-------|------|------|
| 1 | `api/src/interfaces/embedding.ts`, `...test.ts` | Create | EmbeddingProvider interface + contract tests |
| 2 | `api/src/ollama.ts`, `...test.ts` | Modify/Create | Refactor Ollama to implement EmbeddingProvider |
| 3 | `api/src/providers/openai-embeddings.ts`, `...test.ts` | Create | OpenAI embedding provider |
| 4 | `api/src/providers/embedding-factory.ts`, `...test.ts`, `server.ts` | Create/Modify | Provider factory, wire into server |
| 5 | `api/src/interfaces/vector-store.ts`, `...test.ts` | Create | VectorStore interface + contract tests |
| 6 | `api/src/qdrant.ts`, `...test.ts` | Modify/Create | Refactor Qdrant to implement VectorStore |
| 7 | `api/src/providers/vector-factory.ts`, `...test.ts`, `server.ts` | Create/Modify | Vector factory, wire into server |
| 8 | `api/src/rate-limit.ts`, `...test.ts`, `server.ts`, `package.json` | Create/Modify | Rate limiting plugin |
| 9 | `api/src/logger.ts`, `...test.ts`, `server.ts` | Create/Modify | Structured logging with correlation IDs |
| 10 | `api/src/versioning.ts`, `...test.ts`, `server.ts` | Create/Modify | API versioning with /v1/ prefix |
| 11 | `api/src/health.ts`, `...test.ts`, `server.ts` | Create/Modify | Enhanced health checks |
| 12 | `api/AGENTS.md`, `docs/09-api-reference.md`, `docs/00-vision.md` | Modify | Documentation updates |

**12 tasks, 12 commits.** Each task follows TDD: write failing test, verify failure, implement, verify pass, commit. Total estimated time: 3-4 hours.

### Final server.ts (after all tasks)

For reference, here is the complete `api/src/server.ts` after all tasks are complete:

```typescript
import Fastify from "fastify";
import { randomUUID } from "node:crypto";
import { createEmbeddingProvider } from "./providers/embedding-factory.js";
import { createVectorStore } from "./providers/vector-factory.js";
import { chunkText } from "./chunking.js";
import { registerAuth } from "./auth.js";
import { registerRateLimit } from "./rate-limit.js";
import { createLoggerConfig } from "./logger.js";
import { registerVersionedRoutes } from "./versioning.js";
import { createHealthHandler } from "./health.js";
import type { VectorPoint } from "./interfaces/vector-store.js";

const embedder = createEmbeddingProvider();
const vectorStore = createVectorStore();

const loggerConfig = createLoggerConfig();
const app = Fastify({
  logger: loggerConfig,
  genReqId: loggerConfig.genReqId,
});

// Add X-Request-Id to all responses for correlation
app.addHook("onSend", async (req, reply) => {
  void reply.header("x-request-id", req.id);
});

registerAuth(app);
await registerRateLimit(app);

// Health check — always unauthenticated, exempt from rate limiting
app.get(
  "/healthz",
  createHealthHandler({
    vectorStore,
    embedder,
    version: "1.0.0",
  }),
);

const DEFAULT_COLLECTION = process.env.QDRANT_COLLECTION || "docs";

function resolveCollection(name?: string): string {
  return name || DEFAULT_COLLECTION;
}

interface IngestItem {
  id?: string;
  text: string;
  source: string;
  metadata?: Record<string, unknown>;
}

interface IngestBody {
  collection?: string;
  items: IngestItem[];
}

interface QueryBody {
  collection?: string;
  query: string;
  topK?: number;
  filter?: Record<string, unknown>;
}

registerVersionedRoutes(app, [
  {
    method: "POST",
    path: "/ingest",
    handler: async (req) => {
      const body = req.body as IngestBody;
      const col = resolveCollection(body.collection);
      await vectorStore.ensureCollection(col, embedder.dimensions);

      const points: VectorPoint[] = [];
      for (const item of body.items) {
        const baseId = item.id ?? randomUUID();
        const chunks = chunkText(item.text);
        const vectors = await embedder.embed(chunks);

        for (let i = 0; i < chunks.length; i++) {
          points.push({
            id: `${baseId}:${i}`,
            vector: vectors[i],
            payload: {
              text: chunks[i],
              source: item.source,
              chunkIndex: i,
              ...(item.metadata ?? {}),
            },
          });
        }
      }
      await vectorStore.upsert(col, points);
      return { ok: true, upserted: points.length };
    },
  },
  {
    method: "POST",
    path: "/query",
    handler: async (req) => {
      const body = req.body as QueryBody;
      const col = resolveCollection(body.collection);
      await vectorStore.ensureCollection(col, embedder.dimensions);

      const [vector] = await embedder.embed([body.query]);
      const topK = body.topK ?? 8;

      const results = await vectorStore.search(col, vector, {
        limit: topK,
        filter: body.filter,
      });

      return {
        ok: true,
        results: results.map((r) => ({
          id: r.id,
          score: r.score,
          source: r.payload.source,
          text: r.payload.text,
          payload: r.payload,
        })),
      };
    },
  },
]);

const PORT = Number(process.env.PORT || "8080");
app.listen({ port: PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

### New module dependency graph

```
server.ts
  ├── providers/embedding-factory.ts
  │     ├── ollama.ts (implements EmbeddingProvider)
  │     └── providers/openai-embeddings.ts (implements EmbeddingProvider)
  ├── providers/vector-factory.ts
  │     └── qdrant.ts (implements VectorStore)
  ├── auth.ts
  ├── rate-limit.ts (@fastify/rate-limit)
  ├── logger.ts (pino config)
  ├── versioning.ts
  ├── health.ts (probes vectorStore + embedder)
  └── chunking.ts

interfaces/
  ├── embedding.ts     → EmbeddingProvider interface
  └── vector-store.ts  → VectorStore, VectorPoint, SearchOptions, SearchResult
```
